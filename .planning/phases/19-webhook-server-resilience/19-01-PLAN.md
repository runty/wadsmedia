---
phase: 19-webhook-server-resilience
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/messaging/telegram-provider.ts
  - src/plugins/telegram-messaging.ts
autonomous: true

must_haves:
  truths:
    - "After a server restart, Telegram webhook is automatically re-registered without manual intervention"
    - "If Telegram webhook registration fails on startup, the system retries with exponential backoff and logs each failure clearly"
    - "The server starts successfully even if webhook registration ultimately fails after all retries"
  artifacts:
    - path: "src/messaging/telegram-provider.ts"
      provides: "getWebhookInfo method for checking current webhook status"
      contains: "getWebhookInfo"
    - path: "src/plugins/telegram-messaging.ts"
      provides: "Retry-capable webhook registration with exponential backoff"
      contains: "retry"
  key_links:
    - from: "src/plugins/telegram-messaging.ts"
      to: "src/messaging/telegram-provider.ts"
      via: "provider.setWebhook and provider.getWebhookInfo calls"
      pattern: "provider\\.(setWebhook|getWebhookInfo)"
---

<objective>
Make Telegram webhook registration resilient to transient failures on server startup.

Purpose: When the server restarts (after downtime, deploy, or crash), webhook registration may fail if the Telegram API is temporarily unreachable or the tunnel is still initializing. Currently, a single failure silently prevents the webhook from being registered, requiring manual curl intervention.

Output: Telegram webhook auto-registers on startup with retry/backoff. The provider exposes getWebhookInfo for downstream health checks.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@src/messaging/telegram-provider.ts
@src/plugins/telegram-messaging.ts
@src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getWebhookInfo to TelegramMessagingProvider</name>
  <files>src/messaging/telegram-provider.ts</files>
  <action>
Add a `getWebhookInfo()` method to TelegramMessagingProvider that calls `this.api.getWebhookInfo()` and returns a typed result with at minimum: `{ url: string; has_custom_certificate: boolean; pending_update_count: number; last_error_date?: number; last_error_message?: string }`.

Import the WebhookInfo type from `@grammyjs/types` if available, otherwise define the return shape inline. The grammy Api class already has `getWebhookInfo(signal?: AbortSignal): Promise<WebhookInfo>` so this is a thin wrapper.

Place it alongside the existing `setWebhook` and `getMe` methods in the "Telegram-specific public methods" section.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm the new method type-checks. Grep the file for `getWebhookInfo` to confirm it exists.
  </verify>
  <done>TelegramMessagingProvider has a public getWebhookInfo() method that returns webhook status from the Telegram API.</done>
</task>

<task type="auto">
  <name>Task 2: Add retry-with-backoff to webhook registration on startup</name>
  <files>src/plugins/telegram-messaging.ts</files>
  <action>
Replace the current fire-once `await provider.setWebhook(...)` call with a retry-capable registration that:

1. Attempts `provider.setWebhook(TELEGRAM_WEBHOOK_URL, TELEGRAM_WEBHOOK_SECRET)` up to 5 times.
2. On failure, logs the error clearly at `warn` level with attempt number and next retry delay.
3. Uses exponential backoff: 2s, 4s, 8s, 16s between retries (base 2s, multiply by 2 each attempt).
4. On final failure (all 5 attempts exhausted), logs at `error` level with a clear message: "Telegram webhook registration failed after 5 attempts. Webhook must be registered manually or will retry on next server restart."
5. Does NOT throw or crash the server -- the plugin finishes registration regardless. The server must start even if webhook registration fails.
6. On success, logs "Telegram webhook registered" (same as current) plus the attempt number if > 1.

Implementation approach: Write a local `async function registerWebhookWithRetry(provider, url, secret, log)` inside the plugin file. Use a simple for-loop with try/catch and `await new Promise(resolve => setTimeout(resolve, delay))` for backoff. Do NOT use an external retry library.

The retry runs in the foreground during plugin registration (blocking server start until done or exhausted). This is intentional -- we want the webhook ready before accepting traffic. The total worst-case delay is 2+4+8+16 = 30 seconds, acceptable for startup.

Also verify the webhook after successful registration by calling `provider.getWebhookInfo()` and logging the pending_update_count if > 0 (indicates queued updates from downtime that will be delivered once the server is ready).
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm type-checking. Read the file to verify:
1. Retry loop with 5 max attempts exists
2. Exponential backoff delays are present (2000, 4000, 8000, 16000)
3. Error logging includes attempt number
4. Server does not crash on webhook failure
5. getWebhookInfo is called after successful registration
  </verify>
  <done>Server startup retries webhook registration up to 5 times with exponential backoff. Failures are logged clearly. Server starts regardless of webhook registration outcome.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes (no type errors)
2. `npm run check` passes (linting)
3. The telegram-messaging plugin contains retry logic with exponential backoff
4. The TelegramMessagingProvider exposes getWebhookInfo()
5. No throwing on webhook registration failure (server starts regardless)
</verification>

<success_criteria>
- TelegramMessagingProvider has getWebhookInfo() method
- Webhook registration retries up to 5 times with 2/4/8/16s backoff
- Each retry attempt is logged at warn level with attempt number
- Final failure logged at error level with clear remediation message
- Server starts successfully even if all registration attempts fail
- Successful registration logs pending_update_count from getWebhookInfo
</success_criteria>

<output>
After completion, create `.planning/phases/19-webhook-server-resilience/19-01-SUMMARY.md`
</output>
