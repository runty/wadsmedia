---
phase: 11-plex-tautulli-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/media/plex/plex.http.ts
  - src/media/plex/plex.schemas.ts
  - src/media/plex/plex.types.ts
  - src/media/plex/plex.client.ts
  - src/plugins/plex.ts
  - src/conversation/tools/check-plex-library.ts
  - src/conversation/tools/index.ts
  - src/config.ts
  - src/conversation/types.ts
  - src/conversation/engine.ts
  - src/plugins/webhook.ts
  - src/plugins/conversation.ts
  - src/server.ts
  - src/conversation/system-prompt.ts
autonomous: true
user_setup:
  - service: plex
    why: "Plex Media Server library awareness"
    env_vars:
      - name: PLEX_URL
        source: "Your Plex server URL (e.g., http://192.168.1.100:32400)"
      - name: PLEX_TOKEN
        source: "Plex token from Preferences.xml on the Plex server, or from plex.tv/devices.xml when logged in. For local/homelab access, use the token from Preferences.xml (does not expire)."

must_haves:
  truths:
    - "When a user searches for media that already exists in their Plex library, they are told it exists before being offered the option to add it"
    - "User can ask about a TV show and see which seasons are available in Plex (e.g., 'You have seasons 1-4, missing season 5')"
    - "Plex library data is cached in-memory for O(1) lookup by TMDB/TVDB ID, not fetched per-query"
    - "App starts gracefully when PLEX_URL/PLEX_TOKEN are not set (Plex features unavailable)"
  artifacts:
    - path: "src/media/plex/plex.http.ts"
      provides: "Plex-specific HTTP helper with X-Plex-Token auth, Accept: application/json, client identification headers"
      exports: ["plexRequest"]
    - path: "src/media/plex/plex.schemas.ts"
      provides: "Zod schemas for Plex JSON responses (sections, library items with GUIDs, children/seasons)"
      exports: ["PlexSectionsResponseSchema", "PlexLibraryItemsResponseSchema", "PlexChildrenResponseSchema"]
    - path: "src/media/plex/plex.client.ts"
      provides: "PlexClient class with library cache, findByTmdbId, findByTvdbId, getShowAvailability, healthCheck"
      exports: ["PlexClient"]
    - path: "src/plugins/plex.ts"
      provides: "Fastify plugin creating PlexClient, loading cache asynchronously, periodic refresh, health checks"
    - path: "src/conversation/tools/check-plex-library.ts"
      provides: "check_plex_library LLM tool for Plex library existence checks and season/episode availability"
      exports: ["checkPlexLibraryTool"]
  key_links:
    - from: "src/conversation/tools/check-plex-library.ts"
      to: "src/media/plex/plex.client.ts"
      via: "context.plex in ToolContext"
      pattern: "context\\.plex"
    - from: "src/plugins/webhook.ts"
      to: "src/media/plex/plex.client.ts"
      via: "fastify.plex passed into processConversation"
      pattern: "plex: fastify\\.plex"
    - from: "src/plugins/plex.ts"
      to: "src/media/plex/plex.client.ts"
      via: "creates client, loads cache, decorates fastify.plex"
      pattern: "fastify\\.decorate.*plex"
---

<objective>
Build the Plex API client with in-memory library cache and the check_plex_library LLM tool, fully wired into the Fastify server.

Purpose: Users can check if media exists in their Plex library and see TV show season availability. The library cache enables O(1) lookup by TMDB/TVDB ID without per-query API calls to Plex.

Output: PlexClient class, Fastify plugin with async cache loading and periodic refresh, check_plex_library tool registered in conversation engine, all wiring complete.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-plex-tautulli-integration/11-RESEARCH.md

# Existing patterns to follow exactly
@src/media/tmdb/tmdb.http.ts
@src/media/tmdb/tmdb.client.ts
@src/media/tmdb/tmdb.schemas.ts
@src/media/tmdb/tmdb.types.ts
@src/plugins/tmdb.ts
@src/conversation/tools/discover-media.ts
@src/conversation/tools.ts
@src/media/errors.ts

# Files to modify (read current state)
@src/config.ts
@src/conversation/types.ts
@src/conversation/engine.ts
@src/plugins/webhook.ts
@src/plugins/conversation.ts
@src/conversation/tools/index.ts
@src/server.ts
@src/conversation/system-prompt.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Plex HTTP helper, Zod schemas, types, and PlexClient class</name>
  <files>
    src/media/plex/plex.http.ts
    src/media/plex/plex.schemas.ts
    src/media/plex/plex.types.ts
    src/media/plex/plex.client.ts
  </files>
  <action>
Create four files in `src/media/plex/` following the exact patterns from `src/media/tmdb/`.

**plex.http.ts** -- Plex-specific HTTP helper (follow tmdb.http.ts pattern):
- Export `PlexRequestOptions` interface: `{ baseUrl: string, token: string, path: string, query?: Record<string, string | number | boolean>, timeoutMs?: number }`
- Export `plexRequest<T>(options, schema: z.ZodType<T>): Promise<T>`
- Required headers on every request:
  - `X-Plex-Token: {token}` (authentication)
  - `Accept: application/json` (CRITICAL: Plex defaults to XML without this)
  - `X-Plex-Client-Identifier: wadsmedia`
  - `X-Plex-Product: WadsMedia`
  - `X-Plex-Version: 2.0.0`
- Error handling: `TypeError` -> ConnectionError, `DOMException` timeout -> ConnectionError, 401 -> MediaServerError with "Plex authentication failed" message, other non-ok -> MediaServerError with response.text()
- Validate response with `schema.safeParse(json)`, throw `ValidationError` on failure
- Import error classes from `../errors.js` (reuse existing)
- Default timeout: 15000ms (Plex can be slow with large responses)

**plex.schemas.ts** -- Zod schemas for Plex JSON responses:
- `PlexGuidSchema`: `z.object({ id: z.string() })` -- e.g., "tmdb://12345"
- `PlexSectionSchema`: `z.object({ key: z.string(), title: z.string(), type: z.string(), agent: z.string().optional(), scanner: z.string().optional() }).passthrough()`
- `PlexSectionsResponseSchema`: `z.object({ MediaContainer: z.object({ Directory: z.array(PlexSectionSchema) }).passthrough() })`
- `PlexLibraryItemSchema`: `z.object({ ratingKey: z.string(), title: z.string(), year: z.number().optional(), type: z.string().optional(), leafCount: z.number().optional(), viewedLeafCount: z.number().optional(), Guid: z.array(PlexGuidSchema).optional() }).passthrough()`
- `PlexLibraryItemsResponseSchema`: `z.object({ MediaContainer: z.object({ Metadata: z.array(PlexLibraryItemSchema).optional(), size: z.number().optional() }).passthrough() })`
- `PlexChildItemSchema`: `z.object({ ratingKey: z.string(), title: z.string(), index: z.number().optional(), leafCount: z.number().optional(), viewedLeafCount: z.number().optional(), type: z.string().optional() }).passthrough()`
- `PlexChildrenResponseSchema`: `z.object({ MediaContainer: z.object({ Metadata: z.array(PlexChildItemSchema).optional(), size: z.number().optional() }).passthrough() })`
- All schemas use `.passthrough()` on objects (consistent with codebase pattern for forward-compat)

**plex.types.ts** -- TypeScript types:
- `PlexLibraryItem`: `{ ratingKey: string, title: string, year?: number, type: "movie" | "show", sectionTitle: string, leafCount?: number, viewedLeafCount?: number }`
- `PlexLibrarySection`: inferred from `PlexSectionSchema`
- `SeasonAvailability`: `{ seasonNumber: number, episodeCount: number, viewedCount: number, title: string }`
- Use `z.infer<typeof Schema>` where appropriate, manual interfaces where the schema doesn't match the stored shape exactly

**plex.client.ts** -- PlexClient class:
- Constructor takes `(baseUrl: string, token: string)`, stores as private readonly
- Private `libraryCache = new Map<string, PlexLibraryItem>()` -- keyed by `"tmdb:{id}"` and `"tvdb:{id}"`
- Private `cacheReady = false`
- Public `async loadLibraryCache(): Promise<void>`:
  1. Fetch sections via `GET /library/sections` with `PlexSectionsResponseSchema`
  2. Filter sections to `type === "movie"` or `type === "show"` only
  3. For each media section, fetch items via `GET /library/sections/{key}/all` with `query: { includeGuids: 1 }` and 30s timeout, using `PlexLibraryItemsResponseSchema`
  4. For each item, parse `Guid[]` entries with regex `^(\w+):\/\/(.+)$`, store in new Map as `"{provider}:{id}"` -> PlexLibraryItem
  5. Use `Promise.allSettled` to load all sections concurrently
  6. Atomically swap: `this.libraryCache = newCache; this.cacheReady = true`
- Public `findByTmdbId(tmdbId: number): PlexLibraryItem | undefined` -- looks up `tmdb:{tmdbId}`
- Public `findByTvdbId(tvdbId: number): PlexLibraryItem | undefined` -- looks up `tvdb:{tvdbId}`
- Public `async getShowAvailability(ratingKey: string): Promise<SeasonAvailability[]>`:
  1. `GET /library/metadata/{ratingKey}/children` with `PlexChildrenResponseSchema`
  2. Map Metadata entries to `SeasonAvailability` objects: `{ seasonNumber: index, episodeCount: leafCount, viewedCount: viewedLeafCount, title }`
- Public `async healthCheck(): Promise<boolean>`: try GET `/` with a passthrough schema, return true on success, false on any error
- Public getter `isCacheReady: boolean`
- Public getter `cacheSize: number`
  </action>
  <verify>
Run `npx tsc --noEmit` -- all 4 new files compile without errors.
Run `npx biome check src/media/plex/` -- no lint or format errors.
Verify all 4 files exist on disk.
  </verify>
  <done>
PlexClient class compiles with loadLibraryCache, findByTmdbId, findByTvdbId, getShowAvailability, healthCheck methods. Plex HTTP helper handles auth headers, JSON request, and error classification. All Zod schemas validate Plex response shapes with passthrough.
  </done>
</task>

<task type="auto">
  <name>Task 2: Plex Fastify plugin, check_plex_library tool, and full server wiring</name>
  <files>
    src/plugins/plex.ts
    src/conversation/tools/check-plex-library.ts
    src/config.ts
    src/conversation/types.ts
    src/conversation/engine.ts
    src/plugins/webhook.ts
    src/plugins/conversation.ts
    src/conversation/tools/index.ts
    src/server.ts
    src/conversation/system-prompt.ts
  </files>
  <action>
**src/plugins/plex.ts** -- Fastify plugin (follow tmdb.ts pattern):
- Declare module augmentation: `FastifyInstance.plex?: PlexClient`
- Use `fp()` wrapper with `{ name: "plex", dependencies: ["database"] }`
- Read `PLEX_URL` and `PLEX_TOKEN` from `fastify.config`
- If either is missing, log warning "Plex not configured (set PLEX_URL and PLEX_TOKEN), library checks unavailable" and return early
- Create `new PlexClient(PLEX_URL, PLEX_TOKEN)`
- Run health check: `const healthy = await client.healthCheck()`. If unhealthy, log error "Plex server is unreachable or token is invalid, skipping library cache", decorate and return
- Start library cache load ASYNCHRONOUSLY (do NOT await -- do not block startup):
  ```
  client.loadLibraryCache()
    .then(() => { fastify.log.info({ cacheSize: client.cacheSize }, "Plex library cache loaded"); })
    .catch((err) => { fastify.log.error({ err }, "Failed to load Plex library cache on startup"); });
  ```
- Set up periodic cache refresh: `setInterval` every 15 minutes (15 * 60 * 1000), calling `client.loadLibraryCache().catch(err => log)`.
- Set up periodic health check: `setInterval` every 30 minutes, calling `client.healthCheck()`, log warning if unhealthy
- Clean up intervals on `fastify.addHook("onClose", ...)` with `clearInterval`
- Decorate: `fastify.decorate("plex", client)`
- Log info: "Plex client configured, library cache loading..."

**src/conversation/tools/check-plex-library.ts** -- LLM tool (follow discover-media.ts pattern):
- Import `defineTool` from `../tools.js`, `z` from `zod`
- Export `checkPlexLibraryTool = defineTool("check_plex_library", description, schema, "safe", executor)`
- Description: "Check if a movie or TV show exists in the user's Plex library. For TV shows, shows which seasons and episodes are available. Use when the user asks 'do I have...', 'is ... in my library', 'what seasons of ... do I have', or before suggesting the user add something they might already have."
- Schema: `z.object({ title: z.string().describe("The title to check for"), type: z.enum(["movie", "show"]).describe("Whether to check for a movie or TV show"), tmdbId: z.number().optional().describe("TMDB ID for precise matching (for movies)"), tvdbId: z.number().optional().describe("TVDB ID for precise matching (for TV shows)") })`
- Executor:
  1. If `!context.plex`, return `{ error: "Plex is not configured" }`
  2. If `!context.plex.isCacheReady`, return `{ error: "Plex library cache is still loading. Try again in a moment." }`
  3. Try ID-based lookup: if `type === "movie" && tmdbId`, call `context.plex.findByTmdbId(tmdbId)`. If `type === "show" && tvdbId`, call `context.plex.findByTvdbId(tvdbId)`. Also try TMDB ID for shows as fallback: `context.plex.findByTmdbId(tmdbId)` if tmdbId provided.
  4. If not found: return `{ found: false, title, type, message: "{title} was not found in your Plex library" }`
  5. If found and type is "movie": return `{ found: true, title: item.title, year: item.year, type: "movie", library: item.sectionTitle, message: "{title} ({year}) is in your Plex library" }`
  6. If found and type is "show": try `context.plex.getShowAvailability(item.ratingKey)`, filter seasons where `seasonNumber > 0` (exclude specials). Return `{ found: true, title: item.title, year: item.year, type: "show", library: item.sectionTitle, seasons: [...], totalSeasons, totalEpisodes }`. If season fetch fails, return basic `{ found: true, ... , message: "title is in your Plex library (season details unavailable)" }`

**src/config.ts** -- Add 4 new optional env vars (add after BRAVE_SEARCH_API_KEY block):
```
// Plex (optional, for library awareness)
PLEX_URL: z.string().url().optional(),
PLEX_TOKEN: z.string().min(1).optional(),

// Tautulli (optional, for watch history)
TAUTULLI_URL: z.string().url().optional(),
TAUTULLI_API_KEY: z.string().min(1).optional(),
```
Note: Add BOTH Plex and Tautulli config vars now so Plan 11-02 does not need to modify config.ts.

**src/conversation/types.ts** -- Add to ToolContext interface (after `brave?` line):
```
plex?: import("../media/plex/plex.client.js").PlexClient;
tautulli?: import("../media/tautulli/tautulli.client.js").TautulliClient;
```
Note: Add BOTH plex and tautulli to ToolContext now. The tautulli import will resolve once Plan 11-02 creates the file. Since this is a type-only import and the field is optional, TypeScript will not error if the file doesn't exist yet at runtime (it's resolved at build time). If tsc errors on the missing tautulli import, wrap it: `tautulli?: any` with a TODO comment for Plan 11-02 to fix. Prefer the import approach first.

**src/conversation/engine.ts** -- Add to ProcessConversationParams interface (after `brave?` line):
```
plex?: PlexClient;
tautulli?: TautulliClient;
```
Add imports: `import type { PlexClient } from "../media/plex/plex.client.js";`
Destructure `plex` from params (alongside sonarr, radarr, tmdb, brave).
Add `plex` to the ToolContext objects in BOTH places where context is built:
1. The confirmed tool execution context (~line 97-108)
2. The tool call loop context (~line 175-186)
Do NOT add tautulli destructuring yet -- Plan 11-02 will add it when the module exists.

**src/plugins/webhook.ts** -- Add `plex: fastify.plex` to the `processConversation()` call (after `brave: fastify.brave` line).

**src/plugins/conversation.ts** -- Import `checkPlexLibraryTool` from tools/index.ts and register it: `registry.register(checkPlexLibraryTool)`.

**src/conversation/tools/index.ts** -- Add export: `export { checkPlexLibraryTool } from "./check-plex-library.js";`

**src/server.ts** -- Import and register the Plex plugin. Add `import plexPlugin from "./plugins/plex.js";` and `await fastify.register(plexPlugin);` after bravePlugin registration (before conversationPlugin).

**src/conversation/system-prompt.ts** -- Add a new section to SYSTEM_PROMPT after the "Download status:" section and before "Permissions:":
```
Plex library:
- Use check_plex_library to see if media exists in the user's Plex library.
- For TV shows, it shows which seasons and episodes are available.
- IMPORTANT: When a user searches for media, check if it's already in their Plex library before offering to add it. Always mention Plex availability in your response.
- If the user asks "do I have X?" or "what seasons of X do I have?", use check_plex_library.
- For movies, report whether it exists. For shows, list available seasons and episode counts.
```
  </action>
  <verify>
Run `npx tsc --noEmit` -- entire project compiles without errors.
Run `npx biome check src/` -- no lint or format errors across the project.
Verify `check_plex_library` appears in the tool registry by checking the import chain: tools/index.ts exports it, conversation.ts imports and registers it.
Verify PLEX_URL and PLEX_TOKEN appear in config.ts.
Verify `plex` appears in ToolContext in types.ts.
Verify `plex` is passed in webhook.ts processConversation call.
Verify plexPlugin is registered in server.ts.
  </verify>
  <done>
Plex Fastify plugin registers PlexClient with async cache loading and periodic refresh. check_plex_library tool is registered in conversation engine and accessible via ToolContext. All wiring complete: config env vars, ToolContext, engine params, webhook passthrough, server plugin registration, system prompt guidance. App compiles and starts gracefully with or without PLEX_URL/PLEX_TOKEN.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes -- all new and modified files compile
2. `npx biome check src/` passes -- no lint/format issues
3. Files created: plex.http.ts, plex.schemas.ts, plex.types.ts, plex.client.ts, plugins/plex.ts, tools/check-plex-library.ts
4. Files modified: config.ts (4 new env vars), types.ts (plex+tautulli in ToolContext), engine.ts (plex in params and context), webhook.ts (plex passthrough), conversation.ts (register tool), tools/index.ts (export tool), server.ts (register plugin), system-prompt.ts (Plex guidance)
5. Tool count: was 12 (check_status + 11 registered), now 13 (+ check_plex_library)
</verification>

<success_criteria>
- PlexClient class with library cache, GUID indexing, and season/episode availability
- check_plex_library LLM tool registered and accessible to conversation engine
- Plex Fastify plugin with graceful degradation, async cache loading, periodic refresh, health monitoring
- All server wiring complete (config, types, engine, webhook, plugin registration)
- Project compiles cleanly with `npx tsc --noEmit`
</success_criteria>

<output>
After completion, create `.planning/phases/11-plex-tautulli-integration/11-01-SUMMARY.md`
</output>
