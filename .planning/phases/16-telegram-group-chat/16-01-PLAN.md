---
phase: 16-telegram-group-chat
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema.ts
  - src/db/migrate.ts
  - src/conversation/history.ts
  - src/conversation/engine.ts
  - src/conversation/system-prompt.ts
  - src/conversation/types.ts
  - src/messaging/types.ts
  - src/messaging/telegram-provider.ts
autonomous: true

must_haves:
  truths:
    - "Group chat messages are stored with a groupChatId so all members share the same conversation context"
    - "DM conversation history is unchanged -- still keyed by userId with null groupChatId"
    - "processConversation can operate in group mode where history is loaded/saved by groupChatId instead of userId"
    - "Group chat system prompt tells the LLM about multi-user context and user attribution"
  artifacts:
    - path: "src/db/schema.ts"
      provides: "messages table with groupChatId column"
      contains: "groupChatId"
    - path: "src/conversation/history.ts"
      provides: "getGroupHistory and saveGroupMessage functions"
      exports: ["getGroupHistory", "saveGroupMessage"]
    - path: "src/conversation/engine.ts"
      provides: "processConversation with optional groupChatId parameter"
      contains: "groupChatId"
    - path: "src/conversation/system-prompt.ts"
      provides: "GROUP_CHAT_ADDENDUM for multi-user context guidance"
      contains: "GROUP_CHAT_ADDENDUM"
  key_links:
    - from: "src/conversation/engine.ts"
      to: "src/conversation/history.ts"
      via: "getGroupHistory when groupChatId is set"
      pattern: "groupChatId.*getGroupHistory"
    - from: "src/conversation/engine.ts"
      to: "src/conversation/system-prompt.ts"
      via: "buildSystemPrompt with group context params"
      pattern: "buildSystemPrompt.*group"
---

<objective>
Add group conversation history support to the schema and conversation engine so that group chats share context across all members while DM history remains per-user.

Purpose: The success criteria require "shared conversation context so any member can reference previous search results." This requires history to be keyed by group chat ID (not user ID) for group conversations, while preserving the existing per-user history for DMs.

Output: Extended messages schema with groupChatId column, group history functions, engine support for group mode, and group-specific system prompt.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-telegram-dm-integration/15-02-SUMMARY.md
@.planning/phases/15-telegram-dm-integration/15-03-SUMMARY.md
@src/db/schema.ts
@src/conversation/history.ts
@src/conversation/engine.ts
@src/conversation/system-prompt.ts
@src/conversation/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add groupChatId to messages schema and create group history functions</name>
  <files>src/db/schema.ts, src/db/migrate.ts, src/conversation/history.ts</files>
  <action>
1. In `src/db/schema.ts`, add a nullable `groupChatId` column to the `messages` table:
   ```
   groupChatId: text("group_chat_id"),  // null for DMs, Telegram group chat.id for group conversations
   ```
   Place it after the `userId` column. Add a comment: `// Phase 16: null = DM (per-user history), non-null = group chat (shared history)`

2. In `src/db/migrate.ts`, add a migration step that runs:
   ```sql
   ALTER TABLE messages ADD COLUMN group_chat_id TEXT;
   CREATE INDEX idx_messages_group_chat_id ON messages(group_chat_id);
   ```
   Follow the existing migration pattern in the file (check for column existence before adding).

3. In `src/conversation/history.ts`, add two new exported functions:

   `saveGroupMessage(db, params)` -- same as `saveMessage` but accepts `groupChatId: string` in params and saves it. The params type should be the same as `saveMessage` params plus `groupChatId: string`. The user message in group context should still have a userId for attribution, but the groupChatId links it to shared context.

   `getGroupHistory(db, groupChatId: string, limit = 50): ChatMessage[]` -- same pattern as `getHistory` but filters by `groupChatId` instead of `userId`. Uses `eq(messages.groupChatId, groupChatId)`.

   Also update the `ChatMessage` type in `src/conversation/types.ts` to include `groupChatId: string | null`.

   Do NOT modify the existing `saveMessage` or `getHistory` functions -- DM behavior must be unchanged.
  </action>
  <verify>
    `npx tsc --noEmit` passes. Grep for `groupChatId` in schema.ts and history.ts confirms the new column and functions exist.
  </verify>
  <done>
    Messages table has groupChatId column. saveGroupMessage and getGroupHistory functions exist and compile. Existing saveMessage/getHistory unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend processConversation for group mode and add group system prompt</name>
  <files>src/conversation/engine.ts, src/conversation/system-prompt.ts</files>
  <action>
1. In `src/conversation/engine.ts`, add optional fields to `ProcessConversationParams`:
   - `groupChatId?: string` -- when set, use group history instead of per-user history
   - `senderDisplayName?: string` -- the name of the person who sent this specific message (for attribution in group context)
   - `replyToMessageId?: string` -- Telegram message ID to reply to (for threading in groups)

2. Update the conversation flow inside `processConversation` to branch on `groupChatId`:

   **When `groupChatId` is set (group mode):**
   - Step 3 (save user message): Use `saveGroupMessage` with the groupChatId. Prefix the user message content with the sender's name for attribution: `"[SenderName]: original message"`. This way the LLM sees who said what in the shared history.
   - Step 4 (load history): Use `getGroupHistory(db, groupChatId)` instead of `getHistory(db, userId)`.
   - Step 5 (build system prompt): Call `buildSystemPrompt(displayName, providerName, { isGroup: true, senderName: senderDisplayName })` -- the prompt needs to know this is a group and who just spoke.
   - Step 7 (send reply): Add `replyToMessageId` to the outbound message so the bot's reply threads to the user's message in the group.

   **When `groupChatId` is not set (DM mode):**
   - No changes -- existing behavior is preserved exactly.

   For the reply send step, extend the Telegram branch to include `replyToMessageId` when available:
   ```typescript
   await messaging.send({
     to: replyAddress,
     body: result.reply,
     parseMode: "HTML",
     replyToMessageId,
   });
   ```

3. In `src/messaging/types.ts`, add `replyToMessageId?: string` to `OutboundMessage`.

4. In `src/messaging/telegram-provider.ts`, update `send()` to pass `reply_parameters: { message_id: Number(message.replyToMessageId) }` to both `sendMessage` and `sendPhoto` when `replyToMessageId` is set. Use grammy's `reply_parameters` option (Telegram Bot API format).

5. In `src/conversation/system-prompt.ts`:
   - Add a `GROUP_CHAT_ADDENDUM` constant:
     ```
     IMPORTANT CONTEXT -- You are in a GROUP CHAT with multiple users:
     - Messages are prefixed with [Username] to show who said what
     - Address the person who just sent the message by name
     - When someone says "add that" or "the second one", it refers to the last search result shown to the GROUP (shared context)
     - Multiple people may be having overlapping conversations -- use context clues to figure out what each person means
     - Keep responses concise -- you're in a group, not a 1-on-1 chat
     - Reply to the specific person's request, don't recap the whole conversation
     ```
   - Update `buildSystemPrompt` signature to accept an optional third parameter `opts?: { isGroup?: boolean; senderName?: string }`. When `opts.isGroup` is true, append `GROUP_CHAT_ADDENDUM`. When `opts.senderName` is set, append `"\n\nThe current message is from ${senderName}."` instead of the generic user name line.
   - The Telegram addendum and group addendum should both be appended when in a Telegram group chat (they are complementary, not exclusive).
  </action>
  <verify>
    `npx tsc --noEmit` passes. Grep for `GROUP_CHAT_ADDENDUM` in system-prompt.ts. Grep for `groupChatId` in engine.ts confirms branching logic exists. Grep for `replyToMessageId` in types.ts and telegram-provider.ts.
  </verify>
  <done>
    processConversation supports group mode via groupChatId parameter. Group history is shared across all users in the same group. User messages are attributed with sender name prefix. Bot replies thread to the triggering message. System prompt includes group context guidance. DM behavior unchanged.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `groupChatId` column exists in messages table schema
- `saveGroupMessage` and `getGroupHistory` are exported from history.ts
- `processConversation` accepts `groupChatId` and branches on it
- `buildSystemPrompt` supports group mode with `GROUP_CHAT_ADDENDUM`
- `OutboundMessage` has `replyToMessageId` field
- `TelegramMessagingProvider.send()` passes `reply_parameters` when `replyToMessageId` is set
- Existing DM flow (no groupChatId) is completely unchanged
</verification>

<success_criteria>
The conversation engine supports two modes: DM (existing, per-user history) and group (new, per-groupChatId shared history with user attribution). The schema, history functions, engine branching, reply threading, and system prompt are all in place for Plan 02 to wire up the webhook route.
</success_criteria>

<output>
After completion, create `.planning/phases/16-telegram-group-chat/16-01-SUMMARY.md`
</output>
