---
phase: 16-telegram-group-chat
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - src/plugins/telegram-webhook.ts
  - src/messaging/telegram-provider.ts
  - src/config.ts
autonomous: true
user_setup:
  - service: telegram
    why: "Bot must have Privacy Mode disabled to receive all group messages (not just @mentions/replies)"
    dashboard_config:
      - task: "Disable Privacy Mode for the bot"
        location: "BotFather -> /mybots -> select bot -> Bot Settings -> Group Privacy -> Turn off"

must_haves:
  truths:
    - "Bot responds to @mentions in a group chat with full conversational capabilities"
    - "Bot detects and responds to obvious media requests in group chat without requiring @mention"
    - "Group chat maintains shared conversation context so any member can reference previous search results"
    - "Each message in group chat is attributed to the correct WadsMedia user"
  artifacts:
    - path: "src/plugins/telegram-webhook.ts"
      provides: "Group chat handler with activation filtering and user resolution"
      contains: "group"
    - path: "src/config.ts"
      provides: "TELEGRAM_BOT_USERNAME config var for mention detection"
      contains: "TELEGRAM_BOT_USERNAME"
  key_links:
    - from: "src/plugins/telegram-webhook.ts"
      to: "src/conversation/engine.ts"
      via: "processConversation with groupChatId set"
      pattern: "processConversation.*groupChatId"
    - from: "src/plugins/telegram-webhook.ts"
      to: "src/users/user.service.ts"
      via: "findUserByTelegramChatId with from.id for group user resolution"
      pattern: "findUserByTelegramChatId"
---

<objective>
Wire group chat handling into the Telegram webhook route with activation filtering, per-user resolution from from.id, and rate limiting.

Purpose: This plan connects the group conversation infrastructure (Plan 01) to actual Telegram group messages, implementing the activation logic that decides which messages the bot responds to and resolving each sender to their WadsMedia user account.

Output: Complete group chat support in the Telegram webhook -- bot responds to @mentions, replies to bot messages, and obvious media keyword messages in groups, with shared context and per-user attribution.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-telegram-group-chat/16-01-SUMMARY.md
@src/plugins/telegram-webhook.ts
@src/messaging/telegram-provider.ts
@src/users/user.service.ts
@src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add activation detection helpers and bot username config</name>
  <files>src/plugins/telegram-webhook.ts, src/config.ts</files>
  <action>
1. In `src/config.ts`, add `TELEGRAM_BOT_USERNAME` as an optional string env var:
   ```
   TELEGRAM_BOT_USERNAME: z.string().min(1).optional(),
   ```
   This is the bot's username WITHOUT the @ prefix (e.g., "WadsMediaBot"). Used for @mention detection in group chats. It could also be fetched dynamically via `getMe()`, but a config var is simpler and avoids a startup API call.

2. In `src/plugins/telegram-webhook.ts`, add the following helper functions ABOVE the plugin export (module-level, not inside the plugin):

   **`isBotMention(text: string, botUsername: string): boolean`**
   - Returns true if the text contains `@botUsername` (case-insensitive)
   - Also check for the mention in Telegram's `entities` array if available (more reliable than text matching), but text matching is the fallback

   **`isReplyToBot(update: Record<string, unknown>, botUsername: string): boolean`**
   - For message updates: check if `message.reply_to_message.from.username` equals botUsername
   - For callback_query updates: always return true (callback queries are always directed at the bot)
   - Return false otherwise

   **`isObviousMediaRequest(text: string): boolean`**
   - Check if the message text matches media-related patterns using a keyword list
   - Keywords to detect (case-insensitive, word boundaries where practical):
     - Action verbs: "search for", "find me", "look up", "add ", "download ", "grab "
     - Direct queries: "have you seen", "anyone seen", "is .* on plex", "what about"
     - Media nouns combined with action context: "movie", "show", "series", "anime", "film" when combined with action verbs above
   - Implementation: Create a list of regex patterns. If ANY pattern matches, return true.
   - Keep it simple -- false negatives are acceptable (user can always @mention), but false positives waste API calls. Lean toward precision over recall.
   - Example matches: "search for breaking bad", "add the matrix", "anyone seen squid game", "download interstellar", "find me a good horror movie"
   - Example non-matches: "what's for dinner", "hey everyone", "lol that movie was terrible" (commentary, not a request)

   **`shouldActivateInGroup(text: string, update: Record<string, unknown>, botUsername: string): boolean`**
   - Returns true if ANY of: isBotMention, isReplyToBot, isObviousMediaRequest
   - This is the single activation gate for group messages

   **`stripBotMention(text: string, botUsername: string): string`**
   - Removes `@botUsername` from the message text (so the LLM doesn't see the @mention as part of the query)
   - Trim whitespace after removal
  </action>
  <verify>
    `npx tsc --noEmit` passes. Grep for `shouldActivateInGroup` in telegram-webhook.ts. Grep for `TELEGRAM_BOT_USERNAME` in config.ts.
  </verify>
  <done>
    Activation detection functions exist and compile. Bot username is configurable. The functions are ready to be called from the webhook handler in Task 2.
  </done>
</task>

<task type="auto">
  <name>Task 2: Handle group chat messages in the webhook route</name>
  <files>src/plugins/telegram-webhook.ts, src/messaging/telegram-provider.ts</files>
  <action>
1. In `src/plugins/telegram-webhook.ts`, restructure the chat type handling in the POST /webhook/telegram handler:

   **Replace the private-chat-only filter** (the `if (chatType !== "private") return` block) with branching logic:

   ```
   if (chatType === "private") {
     // ... existing DM handling (unchanged)
   } else if (chatType === "group" || chatType === "supergroup") {
     // ... new group chat handling (see below)
   } else {
     // channel or unknown -- ignore
     request.log.debug({ chatType }, "Ignoring unsupported chat type");
     return;
   }
   ```

   **For the group chat branch**, implement:

   a. **Extract group chat ID and message ID:**
      - `groupChatId = String(rawMessage.chat.id)` where rawMessage is `rawBody.message` or `rawBody.callback_query.message`
      - `messageId = String(rawMessage.message_id)` -- the Telegram message ID for reply threading
      - The `message.from` from `parseInbound` is `String(chat.id)` -- but for groups we need the SENDER's identity, not the chat identity

   b. **Extract sender identity from `from.id` (NOT `chat.id`):**
      - For message updates: `senderId = String(rawBody.message.from.id)`
      - For callback_query updates: `senderId = String(rawBody.callback_query.from.id)`
      - Also extract `senderFirstName` from `from.first_name` and `senderUsername` from `from.username`
      - IMPORTANT: In groups, `parseInbound` returns `chat.id` as `from`, which is the GROUP ID. We need the individual `from.id` for user resolution.

   c. **Activation check:**
      - Get `botUsername` from `fastify.config.TELEGRAM_BOT_USERNAME`
      - If `botUsername` is not configured, log a warning and skip group processing (can't detect mentions without knowing the username)
      - Call `shouldActivateInGroup(message.body, rawBody, botUsername)`
      - If false, return silently (do not process this message)
      - If true, strip the bot mention from the message body using `stripBotMention`

   d. **Rate limiting (simple in-memory approach):**
      - Create a module-level `Map<string, number[]>` called `groupMessageTimestamps` that maps groupChatId to an array of timestamps (epoch ms)
      - Before processing, check: filter timestamps to last 60 seconds. If >= 15 messages in the last 60s (leaving buffer below 20/min limit), send a rate limit message and return.
      - After passing the check, push current timestamp. Clean up old timestamps (> 60s ago).
      - Rate limit message: reply to the triggering message with "Slow down! I can only handle so many requests at once in a group. Try again in a minute."

   e. **User resolution from sender identity:**
      - Use `findUserByTelegramChatId(fastify.db, senderId)` to find the WadsMedia user
      - If not found, auto-create with `createUser(fastify.db, null, { telegramChatId: senderId, telegramUsername: senderUsername ?? undefined, displayName: senderFirstName, status: "pending" })`
      - Log: `"Group message from user"` with senderId, senderFirstName, groupChatId
      - If user is not active, reply (threaded to their message) with appropriate status message:
        - pending: "You need to be approved before I can help you. Ask an admin to approve your account."
        - blocked: "Sorry, your access has been revoked."
        - Then return.

   f. **Process conversation in group mode:**
      - Send typing indicator to the GROUP chat: `fastify.telegramMessaging!.sendChatAction(groupChatId, "typing")`
      - Call `processConversation` with:
        - `userId: user.id` (for permissions, media tracking)
        - `replyAddress: groupChatId` (replies go to the group)
        - `displayName: user.displayName`
        - `isAdmin: user.isAdmin`
        - `messageBody: strippedMessage` (with @mention removed)
        - `groupChatId: groupChatId` (enables group history mode)
        - `senderDisplayName: senderFirstName` (for attribution in history)
        - `replyToMessageId: messageId` (for reply threading)
        - All other params same as DM (db, llmClient, registry, etc.)

   g. **Error handling:** Same pattern as DM -- catch errors, send "Sorry, something went wrong." as a reply to the triggering message.

2. In `src/messaging/telegram-provider.ts`, update `parseInbound` to also extract `from.id` for group messages. Actually, since we extract sender info directly from `rawBody` in the webhook, no changes are needed to `parseInbound` -- it remains DM-oriented. The group handler reads `rawBody` directly for sender identity.

   However, DO update `parseInbound` to also handle group message updates by returning the chat ID and body even when chat.type is not "private". Currently it works because it doesn't check chat.type, but verify this is the case.
  </action>
  <verify>
    `npx tsc --noEmit` passes. Test group handling manually by reviewing the code logic:
    - Private chat messages still work (unchanged path)
    - Group messages with @mention are detected and processed
    - Group messages with media keywords are detected and processed
    - Sender is resolved by from.id, not chat.id
    - Replies are threaded to the triggering message
    - Rate limiting prevents more than 15 messages per minute per group
  </verify>
  <done>
    Group chat messages are handled in the Telegram webhook. Bot activates on @mentions, replies to bot, and obvious media requests. Each sender is resolved to their WadsMedia user by from.id. Replies are threaded. Rate limiting prevents exceeding Telegram's 20 msg/min group limit. DM handling is unchanged.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- Private chat (DM) messages still processed correctly (unchanged code path)
- Group chat messages with @mention trigger activation
- Group chat messages with media keywords trigger activation
- Non-activated group messages are silently ignored
- Sender identity resolved from `from.id` (not `chat.id`) in groups
- Bot replies are threaded to the triggering message via `replyToMessageId`
- Rate limiting tracks per-group message frequency
- Non-active users in groups get appropriate status messages
- `TELEGRAM_BOT_USERNAME` config var exists
</verification>

<success_criteria>
All four phase success criteria are met:
1. Bot responds to @mentions in a group chat with full conversational capabilities -- via shouldActivateInGroup -> isBotMention -> processConversation with group mode
2. Bot detects and responds to obvious media requests -- via isObviousMediaRequest keyword detection
3. Group chat maintains shared conversation context -- via groupChatId parameter routing to shared history (Plan 01)
4. Each message attributed to correct WadsMedia user -- via from.id -> findUserByTelegramChatId -> userId for permissions and senderDisplayName for history attribution
</success_criteria>

<output>
After completion, create `.planning/phases/16-telegram-group-chat/16-02-SUMMARY.md`
</output>
