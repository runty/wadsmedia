---
phase: 04-media-server-clients
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/media/errors.ts
  - src/media/http.ts
  - src/media/sonarr/sonarr.schemas.ts
  - src/media/sonarr/sonarr.types.ts
  - src/media/sonarr/sonarr.client.ts
autonomous: true

must_haves:
  truths:
    - "SonarrClient can search for series by term and return Zod-validated results"
    - "SonarrClient can add a series with quality profile, root folder, and monitoring options"
    - "SonarrClient can remove a series by ID with optional file deletion"
    - "SonarrClient can fetch calendar episodes for a date range"
    - "SonarrClient can fetch the download queue with pagination"
    - "SonarrClient can fetch quality profiles and root folders for caching"
    - "Connection errors produce user-friendly ConnectionError, not raw fetch failures"
    - "Unexpected API response shapes produce ValidationError, not crashes"
  artifacts:
    - path: "src/media/errors.ts"
      provides: "MediaServerError, ConnectionError, ValidationError error classes"
      exports: ["MediaServerError", "ConnectionError", "ValidationError"]
    - path: "src/media/http.ts"
      provides: "Shared apiRequest function wrapping fetch with auth, timeout, Zod validation"
      exports: ["apiRequest"]
    - path: "src/media/sonarr/sonarr.schemas.ts"
      provides: "Zod schemas for all Sonarr API response shapes"
      exports: ["SeriesLookupSchema", "SeriesSchema", "QualityProfileSchema", "RootFolderSchema", "QueueRecordSchema", "QueuePageSchema", "EpisodeSchema"]
    - path: "src/media/sonarr/sonarr.types.ts"
      provides: "TypeScript types inferred from Zod schemas"
      exports: ["SeriesLookupResult", "Series", "QualityProfile", "RootFolder", "QueueRecord", "QueuePage", "Episode", "AddSeriesInput"]
    - path: "src/media/sonarr/sonarr.client.ts"
      provides: "SonarrClient class with all API methods"
      exports: ["SonarrClient"]
  key_links:
    - from: "src/media/sonarr/sonarr.client.ts"
      to: "src/media/http.ts"
      via: "import apiRequest"
      pattern: "import.*apiRequest.*from.*http"
    - from: "src/media/sonarr/sonarr.client.ts"
      to: "src/media/sonarr/sonarr.schemas.ts"
      via: "passes schemas to apiRequest for validation"
      pattern: "apiRequest.*Schema"
    - from: "src/media/http.ts"
      to: "src/media/errors.ts"
      via: "throws ConnectionError on fetch failure, ValidationError on parse failure"
      pattern: "throw new (ConnectionError|ValidationError|MediaServerError)"
---

<objective>
Create the shared HTTP utility, error classes, and the complete Sonarr API client with Zod-validated responses.

Purpose: Establishes the HTTP foundation used by both media server clients and delivers the full Sonarr integration -- search, add, remove, calendar, queue, and profile/folder fetching.

Output: `src/media/errors.ts`, `src/media/http.ts`, `src/media/sonarr/sonarr.schemas.ts`, `src/media/sonarr/sonarr.types.ts`, `src/media/sonarr/sonarr.client.ts`
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-media-server-clients/04-RESEARCH.md

@src/config.ts
@src/server.ts
@src/plugins/messaging.ts
@src/plugins/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Shared HTTP utility and error classes</name>
  <files>src/media/errors.ts, src/media/http.ts</files>
  <action>
Create `src/media/errors.ts` with three error classes:
- `MediaServerError` extends Error: takes `statusCode: number` and `responseBody: string`, stores both as properties. Used when API returns non-2xx.
- `ConnectionError` extends Error: takes `message: string`. Used when server is unreachable or times out.
- `ValidationError` extends Error: takes `endpoint: string` and `zodError: z.ZodError` (from zod v4). Stores both. Used when response fails Zod validation.

Create `src/media/http.ts` with:
- `HttpRequestOptions` interface: `baseUrl: string`, `apiKey: string`, `path: string`, `method?: "GET" | "POST" | "PUT" | "DELETE"`, `body?: unknown`, `query?: Record<string, string | number | boolean>`, `timeoutMs?: number`
- `apiRequest<T>(options: HttpRequestOptions, schema: z.ZodType<T>): Promise<T>` function:
  - Constructs URL using `new URL(\`/api/v3/\${path}\`, baseUrl)` and appends query params via URLSearchParams
  - Sets headers: `X-Api-Key`, `Content-Type: application/json`, `Accept: application/json`
  - Uses `AbortSignal.timeout(timeoutMs)` with default 10000ms
  - Wraps `fetch` call in try/catch: catch `TypeError` (fetch failed / ECONNREFUSED) -> throw `ConnectionError` with server name derived from baseUrl hostname; catch `DOMException` with name "TimeoutError" -> throw `ConnectionError` with timeout message
  - On non-ok response: throw `MediaServerError(response.status, await response.text())`
  - For DELETE method: return `undefined as T` (DELETE returns empty body)
  - Parse JSON, run `schema.safeParse(json)`, on failure throw `ValidationError(path, result.error)`, on success return `result.data`
- Also export a `apiRequestVoid(options: Omit<HttpRequestOptions, never>): Promise<void>` for DELETE operations that avoids the schema parameter entirely. This accepts same options but does not parse the body. Still checks response.ok and throws MediaServerError on non-2xx.

Use `.js` extensions on all relative imports. Follow existing ESM patterns. Import `z` from "zod".
  </action>
  <verify>Run `npx tsc --noEmit` and confirm no type errors in the new files.</verify>
  <done>errors.ts exports MediaServerError, ConnectionError, ValidationError. http.ts exports apiRequest and apiRequestVoid. All compile cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Sonarr Zod schemas, types, and client class</name>
  <files>src/media/sonarr/sonarr.schemas.ts, src/media/sonarr/sonarr.types.ts, src/media/sonarr/sonarr.client.ts</files>
  <action>
Create `src/media/sonarr/sonarr.schemas.ts` with Zod schemas using `.passthrough()` on all object schemas to tolerate unknown fields from API updates:

- `ImageSchema`: `{ coverType: z.string(), remoteUrl: z.string().optional(), url: z.string().optional() }.passthrough()`
- `SeasonSchema`: `{ seasonNumber: z.number(), monitored: z.boolean() }.passthrough()`
- `SeriesLookupSchema`: `{ title: z.string(), sortTitle: z.string(), status: z.string(), overview: z.string().nullable(), network: z.string().nullable(), year: z.number(), runtime: z.number(), tvdbId: z.number(), imdbId: z.string().nullable(), tvMazeId: z.number().optional(), titleSlug: z.string(), images: z.array(ImageSchema), seasons: z.array(SeasonSchema), genres: z.array(z.string()), certification: z.string().nullable().optional(), firstAired: z.string().nullable().optional(), added: z.string().optional(), ratings: z.object({}).passthrough().optional(), id: z.number() }.passthrough()`
- `SeriesSchema`: Same fields as SeriesLookupSchema but `id` is required as `z.number()` (non-zero after add). Reuse by extending or duplicating -- simpler to just alias since passthrough handles it. Use the same schema as lookup; after POST the id will be non-zero.
- `QualityProfileSchema`: `{ id: z.number(), name: z.string(), upgradeAllowed: z.boolean().optional(), cutoff: z.number().optional() }.passthrough()`
- `RootFolderSchema`: `{ id: z.number(), path: z.string(), freeSpace: z.number().optional() }.passthrough()`
- `EpisodeSchema`: `{ id: z.number(), seriesId: z.number(), seasonNumber: z.number(), episodeNumber: z.number(), title: z.string().nullable().optional(), airDateUtc: z.string().nullable().optional(), hasFile: z.boolean().optional(), monitored: z.boolean().optional() }.passthrough()` -- used for calendar responses
- `QueueRecordSchema`: `{ id: z.number(), seriesId: z.number().optional(), episodeId: z.number().optional(), title: z.string().nullable().optional(), size: z.number().optional(), sizeleft: z.number().optional(), status: z.string().optional(), trackedDownloadStatus: z.string().nullable().optional(), trackedDownloadState: z.string().nullable().optional(), timeleft: z.string().nullable().optional(), estimatedCompletionTime: z.string().nullable().optional() }.passthrough()`
- `QueuePageSchema`: `{ page: z.number(), pageSize: z.number(), totalRecords: z.number(), records: z.array(QueueRecordSchema) }.passthrough()`

Create `src/media/sonarr/sonarr.types.ts`:
- Export `z.infer<typeof Schema>` for each schema: `SeriesLookupResult`, `Series` (alias of SeriesLookupResult), `QualityProfile`, `RootFolder`, `Episode`, `QueueRecord`, `QueuePage`
- Define and export `AddSeriesInput` as a plain TypeScript interface (NOT a Zod schema -- this is a request body, not a response):
  - Required: `title: string`, `tvdbId: number`, `qualityProfileId: number`, `rootFolderPath: string`, `titleSlug: string`, `images: Array<{ coverType: string; remoteUrl?: string; url?: string }>`, `seasons: Array<{ seasonNumber: number; monitored: boolean }>`, `monitored: boolean`
  - Optional: `seasonFolder?: boolean`, `seriesType?: "standard" | "daily" | "anime"`, `tags?: number[]`, `addOptions?: { searchForMissingEpisodes?: boolean; monitor?: "all" | "future" | "missing" | "existing" | "pilot" | "firstSeason" | "lastSeason" | "none" }`

Create `src/media/sonarr/sonarr.client.ts`:
- `SonarrClient` class with constructor `(baseUrl: string, apiKey: string)`
- Private method `request<T>(path, schema, opts?)` that calls `apiRequest` with baseUrl/apiKey baked in. For search operations, use `timeoutMs: 30_000` (search proxies to TheTVDB and can be slow). For all other operations, use default 10_000ms.
- Public methods:
  - `searchSeries(term: string): Promise<SeriesLookupResult[]>` -- GET `series/lookup?term={term}`, validates with `z.array(SeriesLookupSchema)`
  - `getSeries(): Promise<Series[]>` -- GET `series`, validates with `z.array(SeriesLookupSchema)`
  - `addSeries(input: AddSeriesInput): Promise<Series>` -- POST `series` with body, validates response with `SeriesLookupSchema`
  - `removeSeries(id: number, opts?: { deleteFiles?: boolean; addImportListExclusion?: boolean }): Promise<void>` -- uses `apiRequestVoid` with DELETE `series/${id}` and query params from opts (default both false)
  - `getCalendar(start: string, end: string): Promise<Episode[]>` -- GET `calendar?start={start}&end={end}&includeSeries=true`, validates with `z.array(EpisodeSchema)`
  - `getQueue(opts?: { page?: number; pageSize?: number }): Promise<QueuePage>` -- GET `queue` with query params (defaults: page=1, pageSize=20, sortKey="timeleft", sortDirection="ascending"), validates with `QueuePageSchema`
  - `getQualityProfiles(): Promise<QualityProfile[]>` -- GET `qualityprofile`, validates with `z.array(QualityProfileSchema)`
  - `getRootFolders(): Promise<RootFolder[]>` -- GET `rootfolder`, validates with `z.array(RootFolderSchema)`

Use `.js` extensions on all relative imports.
  </action>
  <verify>Run `npx tsc --noEmit` and confirm no type errors. Run `npx biome check src/media/` to confirm code style compliance.</verify>
  <done>SonarrClient class compiles cleanly with all 8 public methods. Zod schemas defined with passthrough. Types inferred from schemas. AddSeriesInput interface defined with required fields from research (title, tvdbId, qualityProfileId, rootFolderPath, titleSlug, images, seasons, monitored).</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npx biome check src/media/` passes with zero errors
- `src/media/errors.ts` exports 3 error classes
- `src/media/http.ts` exports apiRequest and apiRequestVoid
- `src/media/sonarr/sonarr.client.ts` exports SonarrClient with searchSeries, getSeries, addSeries, removeSeries, getCalendar, getQueue, getQualityProfiles, getRootFolders
- All schemas use `.passthrough()` to tolerate unknown API fields
</verification>

<success_criteria>
SonarrClient class exists with all 8 API methods, backed by a shared HTTP utility that handles auth injection, timeout, error classification, and Zod response validation. Error classes provide clear ConnectionError vs MediaServerError vs ValidationError distinction.
</success_criteria>

<output>
After completion, create `.planning/phases/04-media-server-clients/04-01-SUMMARY.md`
</output>
