---
phase: 04-media-server-clients
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/media/radarr/radarr.schemas.ts
  - src/media/radarr/radarr.types.ts
  - src/media/radarr/radarr.client.ts
autonomous: true

must_haves:
  truths:
    - "RadarrClient can search for movies by term and return Zod-validated results"
    - "RadarrClient can look up a movie by TMDB ID"
    - "RadarrClient can add a movie with quality profile, root folder, minimum availability, and monitoring options"
    - "RadarrClient can remove a movie by ID with optional file deletion"
    - "RadarrClient can fetch upcoming movies for a date range"
    - "RadarrClient can fetch the download queue with pagination"
    - "RadarrClient can fetch quality profiles and root folders for caching"
    - "Connection and validation errors use the same error classes as SonarrClient"
  artifacts:
    - path: "src/media/radarr/radarr.schemas.ts"
      provides: "Zod schemas for all Radarr API response shapes"
      exports: ["MovieLookupSchema", "QualityProfileSchema", "RootFolderSchema", "QueueRecordSchema", "QueuePageSchema"]
    - path: "src/media/radarr/radarr.types.ts"
      provides: "TypeScript types inferred from Zod schemas"
      exports: ["MovieLookupResult", "Movie", "QualityProfile", "RootFolder", "QueueRecord", "QueuePage", "AddMovieInput"]
    - path: "src/media/radarr/radarr.client.ts"
      provides: "RadarrClient class with all API methods"
      exports: ["RadarrClient"]
  key_links:
    - from: "src/media/radarr/radarr.client.ts"
      to: "src/media/http.ts"
      via: "import apiRequest"
      pattern: "import.*apiRequest.*from.*http"
    - from: "src/media/radarr/radarr.client.ts"
      to: "src/media/radarr/radarr.schemas.ts"
      via: "passes schemas to apiRequest for validation"
      pattern: "apiRequest.*Schema"
    - from: "src/media/radarr/radarr.client.ts"
      to: "src/media/errors.ts"
      via: "uses shared error classes (ConnectionError, etc)"
      pattern: "import.*from.*errors"
---

<objective>
Create the complete Radarr API client with Zod-validated responses, mirroring the Sonarr client structure but with Radarr-specific schemas and endpoints.

Purpose: Delivers the full Radarr integration -- search, TMDB lookup, add, remove, calendar (upcoming), queue, and profile/folder fetching. Reuses the shared HTTP utility and error classes from Plan 01.

Output: `src/media/radarr/radarr.schemas.ts`, `src/media/radarr/radarr.types.ts`, `src/media/radarr/radarr.client.ts`
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-media-server-clients/04-RESEARCH.md
@.planning/phases/04-media-server-clients/04-01-SUMMARY.md

@src/media/http.ts
@src/media/errors.ts
@src/media/sonarr/sonarr.schemas.ts
@src/media/sonarr/sonarr.client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Radarr Zod schemas and types</name>
  <files>src/media/radarr/radarr.schemas.ts, src/media/radarr/radarr.types.ts</files>
  <action>
Create `src/media/radarr/radarr.schemas.ts` with Zod schemas using `.passthrough()` on all object schemas:

- `ImageSchema`: `{ coverType: z.string(), remoteUrl: z.string().optional(), url: z.string().optional() }.passthrough()`
- `MovieLookupSchema`: `{ title: z.string(), originalTitle: z.string().optional(), sortTitle: z.string(), status: z.string(), overview: z.string().nullable(), year: z.number(), runtime: z.number(), tmdbId: z.number(), imdbId: z.string().nullable(), titleSlug: z.string(), cleanTitle: z.string().optional(), images: z.array(ImageSchema), genres: z.array(z.string()), ratings: z.object({}).passthrough().optional(), certification: z.string().nullable().optional(), studio: z.string().nullable().optional(), youTubeTrailerId: z.string().nullable().optional(), inCinemas: z.string().nullable().optional(), physicalRelease: z.string().nullable().optional(), digitalRelease: z.string().nullable().optional(), id: z.number() }.passthrough()`
- `QualityProfileSchema`: `{ id: z.number(), name: z.string(), upgradeAllowed: z.boolean().optional(), cutoff: z.number().optional() }.passthrough()` (same shape as Sonarr but defined separately per research recommendation -- no shared abstraction)
- `RootFolderSchema`: `{ id: z.number(), path: z.string(), freeSpace: z.number().optional() }.passthrough()`
- `QueueRecordSchema`: `{ id: z.number(), movieId: z.number().optional(), title: z.string().nullable().optional(), size: z.number().optional(), sizeleft: z.number().optional(), status: z.string().optional(), trackedDownloadStatus: z.string().nullable().optional(), trackedDownloadState: z.string().nullable().optional(), timeleft: z.string().nullable().optional(), estimatedCompletionTime: z.string().nullable().optional(), protocol: z.string().nullable().optional(), downloadClient: z.string().nullable().optional() }.passthrough()` -- note `movieId` instead of Sonarr's `seriesId`/`episodeId`
- `QueuePageSchema`: `{ page: z.number(), pageSize: z.number(), totalRecords: z.number(), records: z.array(QueueRecordSchema) }.passthrough()`

Create `src/media/radarr/radarr.types.ts`:
- Export `z.infer<typeof Schema>` for each schema: `MovieLookupResult`, `Movie` (alias of MovieLookupResult), `QualityProfile`, `RootFolder`, `QueueRecord`, `QueuePage`
- Define and export `AddMovieInput` as a plain TypeScript interface (request body, not response):
  - Required: `title: string`, `tmdbId: number`, `qualityProfileId: number`, `rootFolderPath: string`, `monitored: boolean`, `minimumAvailability: "announced" | "inCinemas" | "released"`
  - Optional: `titleSlug?: string`, `tags?: number[]`, `images?: Array<{ coverType: string; remoteUrl?: string; url?: string }>`, `addOptions?: { searchForMovie?: boolean; monitor?: "movieOnly" | "movieAndCollection" | "none" }`

Use `.js` extensions on all relative imports.
  </action>
  <verify>Run `npx tsc --noEmit` and confirm no type errors.</verify>
  <done>Radarr Zod schemas defined with passthrough. Types inferred from schemas. AddMovieInput includes required `minimumAvailability` field (Radarr-specific, not in Sonarr).</done>
</task>

<task type="auto">
  <name>Task 2: RadarrClient class with all API methods</name>
  <files>src/media/radarr/radarr.client.ts</files>
  <action>
Create `src/media/radarr/radarr.client.ts`:
- `RadarrClient` class with constructor `(baseUrl: string, apiKey: string)`
- Private method `request<T>(path, schema, opts?)` that calls `apiRequest` from `../http.js` with baseUrl/apiKey baked in. For search operations (searchMovies, lookupByTmdbId), use `timeoutMs: 30_000`. For all other operations, use default 10_000ms.
- Public methods:
  - `searchMovies(term: string): Promise<MovieLookupResult[]>` -- GET `movie/lookup?term={term}`, validates with `z.array(MovieLookupSchema)`
  - `lookupByTmdbId(tmdbId: number): Promise<MovieLookupResult>` -- GET `movie/lookup/tmdb?tmdbId={tmdbId}`, validates with `MovieLookupSchema` (single object, not array)
  - `getMovies(): Promise<Movie[]>` -- GET `movie`, validates with `z.array(MovieLookupSchema)`
  - `addMovie(input: AddMovieInput): Promise<Movie>` -- POST `movie` with body, validates response with `MovieLookupSchema`
  - `removeMovie(id: number, opts?: { deleteFiles?: boolean; addImportExclusion?: boolean }): Promise<void>` -- uses `apiRequestVoid` with DELETE `movie/${id}` and query params from opts (default both false). Note: param is `addImportExclusion` (NOT `addImportListExclusion` -- differs from Sonarr)
  - `getUpcoming(start: string, end: string): Promise<Movie[]>` -- GET `calendar?start={start}&end={end}&unmonitored=false`, validates with `z.array(MovieLookupSchema)` (Radarr calendar returns Movie objects, not episodes like Sonarr)
  - `getQueue(opts?: { page?: number; pageSize?: number }): Promise<QueuePage>` -- GET `queue` with query params (defaults: page=1, pageSize=20, sortKey="timeleft", sortDirection="ascending", includeUnknownMovieItems=false), validates with `QueuePageSchema`
  - `getQualityProfiles(): Promise<QualityProfile[]>` -- GET `qualityprofile`, validates with `z.array(QualityProfileSchema)`
  - `getRootFolders(): Promise<RootFolder[]>` -- GET `rootfolder`, validates with `z.array(RootFolderSchema)`

Use `.js` extensions on all relative imports.
  </action>
  <verify>Run `npx tsc --noEmit` and confirm no type errors. Run `npx biome check src/media/radarr/` to confirm code style compliance.</verify>
  <done>RadarrClient class compiles cleanly with all 9 public methods (searchMovies, lookupByTmdbId, getMovies, addMovie, removeMovie, getUpcoming, getQueue, getQualityProfiles, getRootFolders). Uses shared apiRequest/apiRequestVoid from http.ts. Radarr-specific differences handled: tmdbId (not tvdbId), minimumAvailability, addImportExclusion, movie endpoint names, calendar returns movies not episodes.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npx biome check src/media/radarr/` passes with zero errors
- `src/media/radarr/radarr.client.ts` exports RadarrClient with searchMovies, lookupByTmdbId, getMovies, addMovie, removeMovie, getUpcoming, getQueue, getQualityProfiles, getRootFolders
- RadarrClient uses same error classes (ConnectionError, MediaServerError, ValidationError) as SonarrClient
- Radarr-specific API differences are correctly handled (tmdbId, minimumAvailability, addImportExclusion, movie/lookup endpoint paths)
</verification>

<success_criteria>
RadarrClient class exists with all 9 API methods, using the shared HTTP utility from Plan 01. Radarr-specific schema differences (tmdbId vs tvdbId, movieId in queue, minimumAvailability for add, addImportExclusion for delete) are correctly implemented. Zod schemas use passthrough for API update tolerance.
</success_criteria>

<output>
After completion, create `.planning/phases/04-media-server-clients/04-02-SUMMARY.md`
</output>
