---
phase: 18-conversation-reliability
plan: 02
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - src/conversation/engine.ts
  - src/conversation/engine.test.ts
autonomous: true

must_haves:
  truths:
    - "When a user sends multiple messages rapidly before the LLM responds, each message is processed sequentially -- no race condition corrupts conversation context"
    - "When an LLM call fails or errors out, the user's message is NOT persisted to the database"
    - "Only one processConversation call runs at a time per user (DMs) or per group chat (groups)"
    - "A second rapid message waits for the first to complete, then processes with up-to-date history"
  artifacts:
    - path: "src/conversation/engine.ts"
      provides: "Per-user conversation lock and verified deferred persistence"
      exports: ["processConversation"]
    - path: "src/conversation/engine.test.ts"
      provides: "Tests for conversation locking and deferred persistence"
      min_lines: 40
  key_links:
    - from: "src/plugins/webhook.ts"
      to: "src/conversation/engine.ts:processConversation"
      via: "webhook calls processConversation which now acquires lock"
      pattern: "processConversation"
    - from: "src/plugins/telegram-webhook.ts"
      to: "src/conversation/engine.ts:processConversation"
      via: "telegram webhook calls processConversation which now acquires lock"
      pattern: "processConversation"
---

<objective>
Add per-user conversation serialization to prevent rapid messages from corrupting context, and verify/test deferred message persistence.

Purpose: When a user sends multiple messages before the LLM responds (common on Telegram), concurrent processConversation calls can read stale history, produce duplicate tool calls, or interleave DB writes. A simple per-user async lock ensures sequential processing. Additionally, deferred persistence (CONV-02) is already implemented but needs test coverage to prevent regression.

Output: Race-condition-safe conversation processing with verified deferred persistence behavior.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-conversation-reliability/18-01-SUMMARY.md
@src/conversation/engine.ts
@src/conversation/history.ts
@src/plugins/webhook.ts
@src/plugins/telegram-webhook.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Per-user conversation lock in engine.ts</name>
  <files>src/conversation/engine.ts</files>
  <action>
    Add a per-user (and per-group) async lock mechanism to processConversation to serialize concurrent calls for the same user/group.

    Implementation approach -- use a simple Map of promise chains (no external dependency needed):

    ```typescript
    // Module-level lock map
    const conversationLocks = new Map<string, Promise<void>>();

    function withConversationLock(lockKey: string, fn: () => Promise<void>): Promise<void> {
      const prev = conversationLocks.get(lockKey) ?? Promise.resolve();
      const next = prev.then(fn, fn); // Always chain, even if previous errored
      conversationLocks.set(lockKey, next);
      // Clean up after completion to avoid memory leak
      next.then(() => {
        if (conversationLocks.get(lockKey) === next) {
          conversationLocks.delete(lockKey);
        }
      });
      return next;
    }
    ```

    In processConversation, determine the lock key:
    - For group chats: `group:${groupChatId}`
    - For DMs: `user:${userId}`

    Wrap the entire existing try/catch body of processConversation inside `withConversationLock(lockKey, async () => { ... })`.

    The function signature and return type of processConversation do NOT change. Callers (webhook.ts, telegram-webhook.ts) are unaffected.

    Also export `withConversationLock` for testing (or export `conversationLocks` map for test inspection).

    Add a log line at lock acquisition: `log.debug({ lockKey }, "Acquiring conversation lock")` and after release.
  </action>
  <verify>
    `npx tsc --noEmit` compiles cleanly.
    The lock mechanism is visible in the code.
    processConversation still handles errors gracefully (the lock wrapper must not swallow errors).
  </verify>
  <done>
    processConversation serializes concurrent calls for the same user/group via promise chaining. Different users process in parallel. No external dependencies added.
  </done>
</task>

<task type="auto">
  <name>Task 2: Test conversation lock and deferred persistence</name>
  <files>src/conversation/engine.test.ts</files>
  <action>
    Create unit tests that verify:

    1. **Conversation lock serialization:**
       - Import withConversationLock (or the conversationLocks map)
       - Test that two calls with the same lock key execute sequentially (second waits for first)
       - Test that two calls with different lock keys execute in parallel
       - Test that if the first call errors, the second still executes

    2. **Deferred persistence verification:**
       - This is a code-review-as-test approach: write a test that reads engine.ts source and asserts:
         a. saveMessage for user role appears AFTER toolCallLoop call (line ordering)
         b. The catch block does NOT call saveMessage
       - OR, if mocking is feasible: create a minimal mock of processConversation's flow that verifies save order

    Use vitest. The lock tests are straightforward async tests. For deferred persistence, a simple structural assertion (grep the source) is acceptable since the full processConversation requires too many dependencies to mock in a unit test.

    Test file structure:
    ```typescript
    import { describe, it, expect } from 'vitest';
    // Test the lock mechanism
    describe('withConversationLock', () => {
      it('serializes calls with the same key', async () => { ... });
      it('allows parallel calls with different keys', async () => { ... });
      it('continues after error in previous call', async () => { ... });
    });

    describe('deferred persistence', () => {
      it('user message is saved after toolCallLoop in engine.ts', async () => {
        // Read engine.ts, find line positions
        // Assert saveMessage(db, { userId, role: "user" ... }) appears after toolCallLoop
      });
      it('catch block does not persist user message', async () => {
        // Read engine.ts catch block, assert no saveMessage call
      });
    });
    ```
  </action>
  <verify>
    `npx vitest run src/conversation/engine.test.ts` -- all tests pass.
  </verify>
  <done>
    Lock serialization is tested with timing assertions. Deferred persistence is structurally verified. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run` -- all tests pass (both history.test.ts from plan 01 and engine.test.ts from this plan)
2. `npx tsc --noEmit` -- clean compilation
3. `npx biome check src/` -- no lint errors
4. Manual review: processConversation wraps its body in withConversationLock
5. The confirmation flow paths (lines 120-194 in current engine.ts) are NOT wrapped in the lock -- they are fast synchronous DB operations that don't need serialization. Actually, they should be inside the lock too since they read/write history. Ensure the ENTIRE processConversation body is inside the lock.
</verification>

<success_criteria>
- Rapid duplicate messages from the same user are processed sequentially, not concurrently
- Different users' messages still process in parallel
- Deferred persistence behavior is verified by tests
- No new npm dependencies
- TypeScript compiles, Biome passes, all tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/18-conversation-reliability/18-02-SUMMARY.md`
</output>
