---
phase: 13-rcs-rich-messaging-personality
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - src/conversation/message-formatter.ts
  - src/conversation/engine.ts
  - src/conversation/system-prompt.ts
autonomous: true

must_haves:
  truths:
    - "Search results from search_movies, search_series, and discover_media are sent as RCS rich cards with poster images when a content template is available"
    - "When no content template is configured or posterUrl is null, messages fall back to plain text (existing behavior preserved)"
    - "Quick-action suggested reply buttons (Add this, Next result, Check Plex) appear below search result cards"
    - "Assistant responses use a fun, edgy, slightly spicy personality with emojis throughout all conversations"
    - "Button taps from users are treated as typed text by the conversation engine (no special routing needed)"
  artifacts:
    - path: "src/conversation/message-formatter.ts"
      provides: "Detects tool results containing search/discover data and builds rich card OutboundMessage payloads"
      contains: "formatAsRichCard"
    - path: "src/conversation/engine.ts"
      provides: "Integration point: after LLM reply, checks for rich card opportunity and sends via content template when available"
      contains: "contentSid"
    - path: "src/conversation/system-prompt.ts"
      provides: "Rewritten personality: fun, edgy, slightly spicy with emojis, while maintaining conciseness for SMS"
      contains: "emoji"
  key_links:
    - from: "src/conversation/engine.ts"
      to: "src/conversation/message-formatter.ts"
      via: "import and call formatAsRichCard"
      pattern: "formatAsRichCard"
    - from: "src/conversation/message-formatter.ts"
      to: "src/messaging/content-templates.ts"
      via: "uses ensureSearchResultTemplate to get contentSid"
      pattern: "ensureSearchResultTemplate"
    - from: "src/conversation/engine.ts"
      to: "src/messaging/types.ts"
      via: "sends OutboundMessage with contentSid instead of body for rich results"
      pattern: "contentSid"
---

<objective>
Wire the rich card infrastructure from Plan 13-01 into the conversation engine so search results are automatically sent as visual cards, and rewrite the system prompt to give the assistant a fun, edgy personality with emojis.

Purpose: This is where the user-visible changes happen. Plan 13-01 built the plumbing; this plan connects it to the conversation flow and transforms the assistant's character.

Output: Message formatter module, updated conversation engine with rich card sending, and personality-driven system prompt.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-rcs-rich-messaging-personality/13-RESEARCH.md
@.planning/phases/13-rcs-rich-messaging-personality/13-01-SUMMARY.md

@src/conversation/engine.ts
@src/conversation/system-prompt.ts
@src/conversation/tool-loop.ts
@src/conversation/types.ts
@src/messaging/types.ts
@src/messaging/content-templates.ts
@src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create message formatter and wire into conversation engine</name>
  <files>
    src/conversation/message-formatter.ts
    src/conversation/engine.ts
  </files>
  <action>
**src/conversation/message-formatter.ts:**

Create a message formatter that inspects the LLM's tool call history to detect when search/discover results were returned, then builds a rich card `OutboundMessage` as an alternative to the plain text reply.

**Design approach:** After the tool call loop completes and produces a text `reply`, scan the `messagesConsumed` array for the most recent tool result that contains search/discover data. If found, extract the top result's metadata and build a rich card send. The LLM's text reply is still saved to history (it contains the formatted text the LLM composed), but the actual message sent to the user is the rich card.

**Key function:**

```typescript
import type { ChatCompletionMessageParam } from "openai/resources/chat/completions";
import type { OutboundMessage } from "../messaging/types.js";
import { ensureSearchResultTemplate } from "../messaging/content-templates.js";

interface RichCardContext {
  accountSid: string;
  authToken: string;
  messagingServiceSid?: string;
  phoneNumber?: string;
}

interface RichCardResult {
  outboundMessage: OutboundMessage;
  textFallback: string; // The LLM's original text reply (for history)
}

/**
 * Attempt to format the most recent search/discover result as a rich card.
 * Returns null if no rich card is appropriate (no search results, no template config, etc).
 */
export async function formatAsRichCard(
  messagesConsumed: ChatCompletionMessageParam[],
  textReply: string,
  to: string,
  richContext: RichCardContext,
): Promise<RichCardResult | null> {
  // 1. Find the last tool result message that looks like search/discover output
  const searchResult = extractLatestSearchResult(messagesConsumed);
  if (!searchResult) return null;

  // 2. Ensure content template exists (idempotent)
  let contentSid: string;
  try {
    contentSid = await ensureSearchResultTemplate(
      richContext.accountSid,
      richContext.authToken,
    );
  } catch {
    // Template creation failed -- fall back to plain text
    return null;
  }

  // 3. Build content variables
  const variables: Record<string, string> = {
    "1": searchResult.title,
    "2": String(searchResult.year ?? ""),
    "3": searchResult.overview ?? "",
  };
  if (searchResult.posterUrl) {
    variables["4"] = searchResult.posterUrl;
  }

  // 4. Build the OutboundMessage
  const outboundMessage: OutboundMessage = {
    to,
    contentSid,
    contentVariables: JSON.stringify(variables),
    ...(richContext.messagingServiceSid
      ? { messagingServiceSid: richContext.messagingServiceSid }
      : { from: richContext.phoneNumber }),
  };

  return { outboundMessage, textFallback: textReply };
}
```

**Helper: `extractLatestSearchResult`**

Scan messages from the end backward. Look for `role: "tool"` messages whose JSON content contains a `results` array where items have `title` and (`tmdbId` or `tvdbId`). Extract the first result from the array:

```typescript
interface SearchResultData {
  title: string;
  year: number | string | null;
  overview: string | null;
  posterUrl: string | null;
}

function extractLatestSearchResult(
  messages: ChatCompletionMessageParam[],
): SearchResultData | null {
  // Walk backward through messages to find the most recent tool result
  for (let i = messages.length - 1; i >= 0; i--) {
    const msg = messages[i];
    if (msg.role !== "tool" || typeof msg.content !== "string") continue;

    try {
      const parsed = JSON.parse(msg.content);
      // Check for results array pattern (search_movies, search_series, discover_media)
      if (Array.isArray(parsed.results) && parsed.results.length > 0) {
        const top = parsed.results[0];
        if (top.title && (top.tmdbId !== undefined || top.tvdbId !== undefined)) {
          return {
            title: top.title,
            year: top.year ?? null,
            overview: top.overview ?? null,
            posterUrl: top.posterUrl ?? null,
          };
        }
      }
    } catch {
      // Not JSON or not the expected shape -- skip
    }
  }
  return null;
}
```

Export both `formatAsRichCard` and `extractLatestSearchResult` (the latter for testability).

**src/conversation/engine.ts:**

Modify the main reply sending in `processConversation()`. After the tool call loop returns, attempt to format as a rich card. If a rich card is produced, send that instead of the plain text.

Add `formatAsRichCard` import at the top:
```typescript
import { formatAsRichCard } from "./message-formatter.js";
```

Replace the final send block (around line 222-228) with:

```typescript
// Attempt rich card send for search/discover results
let sent = false;
if (config.TWILIO_ACCOUNT_SID && config.TWILIO_AUTH_TOKEN) {
  const richCard = await formatAsRichCard(
    result.messagesConsumed,
    result.reply,
    userPhone,
    {
      accountSid: config.TWILIO_ACCOUNT_SID,
      authToken: config.TWILIO_AUTH_TOKEN,
      messagingServiceSid: config.TWILIO_MESSAGING_SERVICE_SID,
      phoneNumber: config.TWILIO_PHONE_NUMBER,
    },
  );

  if (richCard) {
    try {
      log.info("Sending rich card reply");
      await messaging.send(richCard.outboundMessage);
      sent = true;
      log.info("Rich card sent");
    } catch (richErr) {
      log.warn({ err: richErr }, "Rich card send failed, falling back to text");
      // Fall through to plain text send
    }
  }
}

if (!sent) {
  log.info({ replyLength: result.reply.length }, "Sending reply via messaging");
  await messaging.send({
    to: userPhone,
    body: result.reply,
    from: config.TWILIO_PHONE_NUMBER,
  });
  log.info("Reply sent");
}
```

**Important:** The rich card send wraps in try/catch and falls back to plain text if anything goes wrong. This ensures the user always gets a response even if template creation fails, the Twilio Content API is down, or the account does not have RCS/MMS capability.

**Button tap handling:** No special engine logic needed. When a user taps "Add this", Twilio sends the button's title text in the `Body` field. The existing `message.body` parsing picks it up, and the LLM handles "Add this" naturally from conversation context (it sees the prior search results in history). The `buttonPayload` field parsed in 13-01 is available for future use if explicit routing is ever needed, but is not required now.
  </action>
  <verify>Run `npx tsc --noEmit` -- no type errors. Verify that `processConversation` still has the plain-text fallback path for when rich cards are not applicable or fail. Check that the import of `formatAsRichCard` resolves.</verify>
  <done>Search and discover results are sent as rich cards when content template infrastructure is available, with automatic plain-text fallback. Button taps flow through naturally as typed text.</done>
</task>

<task type="auto">
  <name>Task 2: Rewrite system prompt with fun, edgy personality</name>
  <files>src/conversation/system-prompt.ts</files>
  <action>
Rewrite the `SYSTEM_PROMPT` constant in `src/conversation/system-prompt.ts` to give the assistant a fun, edgy, slightly spicy personality that uses emojis throughout all conversations. The personality must:

1. **Keep SMS-friendly brevity** -- the "be concise" rule is even more important with personality. Spicy but SHORT.
2. **Use emojis naturally** -- not every word, but sprinkled throughout responses. For media results: movie camera, popcorn, TV, star, fire, etc.
3. **Be slightly irreverent/playful** -- like a friend who knows a lot about movies/TV, not a corporate assistant.
4. **Maintain helpfulness** -- personality is flavor, not a barrier to getting things done.

Replace the entire `SYSTEM_PROMPT` string. Keep the `buildSystemPrompt` function unchanged. The new prompt should preserve ALL the operational instructions (search behavior, library management, library routing, confirmation handling, discovery behavior, web search, Plex, watch history, download status, permissions) but rewrite the tone/framing sections.

**New personality framing (beginning of prompt):**
```
You are Wads -- a sharp-tongued, movie-obsessed media assistant who lives and breathes entertainment. You're like that friend who always has the perfect recommendation and won't let anyone settle for mid content. You're helpful, you're fast, and you've got opinions.

Vibe: Fun, slightly spicy, unapologetically enthusiastic about great media. Use emojis naturally throughout your responses (but don't overdo it -- you're witty, not a slot machine).
```

**Response format section rewrite:**
- Replace "Be concise. Users are texting via SMS" with personality-aware brevity: "Keep it tight -- you're texting, not writing a thesis. Short, punchy, scannable."
- Add emoji guidance: "Use emojis to add flavor: film/TV emojis for results, fire for great finds, eyes for interesting picks, skull for horror, etc."
- Replace "Refer to the user by name when available" with "Use the user's name like you're talking to a friend."

**Key personality tweaks to operational sections:**
- Search results: When presenting results, the LLM should add personality ("Ooh, solid pick!" / "This one's a banger" / "You sure about this one? lol") but still include all required data.
- Add operations: Confirmation should have flair ("On it! Added X to the collection" / "Done and done. X is downloading now")
- Error handling: Keep it friendly and light ("Welp, that didn't work. Try again?")
- Permissions: "Only the boss can delete stuff around here. But you can search, add, discover -- go wild."

**Critical:** Do NOT change any tool-specific instructions (which tools to call, parameter names, when to use which tool). Only change the personality/tone wrapper. The operational logic must remain identical.

The `buildSystemPrompt` function appending the user's display name should remain unchanged.
  </action>
  <verify>Run `npx tsc --noEmit` -- no type errors. Read the new prompt and verify: (1) all operational instructions are preserved (search behavior, library management, routing, confirmation, discovery, web search, Plex, watch history, downloads, permissions), (2) personality is fun/edgy/spicy with emoji guidance, (3) brevity is maintained or reinforced.</verify>
  <done>System prompt gives the assistant a fun, edgy, slightly spicy personality with emoji usage throughout, while preserving all operational instructions for tool usage, search behavior, library management, and permissions.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `message-formatter.ts` exports `formatAsRichCard` and `extractLatestSearchResult`
3. `engine.ts` attempts rich card send for search/discover results
4. `engine.ts` falls back to plain text when rich card is not available or fails
5. System prompt contains personality keywords (fun, spicy, emojis, etc.)
6. System prompt preserves all tool-specific operational instructions
7. No existing messaging.send() calls broken
</verification>

<success_criteria>
- Search/discover results are sent as rich cards with poster images and quick-action buttons when content template infrastructure is configured
- Plain text fallback works when templates are unavailable
- Button taps are handled naturally through existing text-based conversation flow
- Assistant personality is fun, edgy, slightly spicy with emojis
- No regressions in conversation processing, tool execution, or message delivery
</success_criteria>

<output>
After completion, create `.planning/phases/13-rcs-rich-messaging-personality/13-02-SUMMARY.md`
</output>
