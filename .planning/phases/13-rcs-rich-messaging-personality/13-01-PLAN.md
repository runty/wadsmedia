---
phase: 13-rcs-rich-messaging-personality
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/messaging/types.ts
  - src/messaging/twilio-provider.ts
  - src/messaging/content-templates.ts
  - src/conversation/tools/search-movies.ts
  - src/conversation/tools/search-series.ts
autonomous: true

must_haves:
  truths:
    - "OutboundMessage supports sending rich cards via contentSid + contentVariables as an alternative to body text"
    - "InboundMessage captures ButtonPayload and ButtonText from button tap webhooks"
    - "TwilioMessagingProvider.send() passes contentSid/contentVariables to Twilio API when present (without body)"
    - "Content templates can be created and retrieved via the Twilio Content REST API"
    - "search_movies and search_series tool results include posterUrl for each result"
  artifacts:
    - path: "src/messaging/types.ts"
      provides: "Extended OutboundMessage with contentSid/contentVariables, extended InboundMessage with buttonPayload/buttonText"
      contains: "contentSid"
    - path: "src/messaging/twilio-provider.ts"
      provides: "Updated send() supporting rich card messages, updated parseInbound() extracting button fields"
      contains: "contentSid"
    - path: "src/messaging/content-templates.ts"
      provides: "Content template creation and retrieval utilities via Twilio Content REST API"
      contains: "createSearchResultTemplate"
    - path: "src/conversation/tools/search-movies.ts"
      provides: "posterUrl in search results from Radarr images array"
      contains: "posterUrl"
    - path: "src/conversation/tools/search-series.ts"
      provides: "posterUrl in search results from Sonarr images array"
      contains: "posterUrl"
  key_links:
    - from: "src/messaging/twilio-provider.ts"
      to: "src/messaging/types.ts"
      via: "OutboundMessage contentSid field"
      pattern: "contentSid"
    - from: "src/messaging/content-templates.ts"
      to: "Twilio Content API"
      via: "native fetch() to content.twilio.com/v1/Content"
      pattern: "content\\.twilio\\.com"
---

<objective>
Build the messaging infrastructure for RCS rich cards: extend message types with content template fields and button interaction fields, update the Twilio provider to support both plain text and rich card sending, create a content template management module, and add poster URLs to search tool results.

Purpose: Establishes the foundation for sending visual search results with poster images and quick-action buttons. Without this infrastructure, the engine (Plan 13-02) has no way to send rich messages.

Output: Extended messaging types, updated Twilio provider, content template utilities, and poster-enriched search tool results.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-rcs-rich-messaging-personality/13-RESEARCH.md

@src/messaging/types.ts
@src/messaging/twilio-provider.ts
@src/conversation/tools/search-movies.ts
@src/conversation/tools/search-series.ts
@src/media/radarr/radarr.schemas.ts
@src/media/sonarr/sonarr.schemas.ts
@src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend messaging types and update Twilio provider</name>
  <files>
    src/messaging/types.ts
    src/messaging/twilio-provider.ts
  </files>
  <action>
**src/messaging/types.ts:**

Extend `OutboundMessage` to support rich card sending. The `contentSid` and `body` fields are mutually exclusive -- when `contentSid` is present, `body` must not be sent to Twilio. Make both `body` and `contentSid` optional (one or the other must be present at send time):

```typescript
export interface OutboundMessage {
  to: string;
  // Plain text (mutually exclusive with contentSid)
  body?: string;
  // Content Template rich card (mutually exclusive with body)
  contentSid?: string;
  contentVariables?: string; // JSON string of {"1": "val", "2": "val", ...}
  // Sender identification (one of these)
  messagingServiceSid?: string;
  from?: string;
}
```

Extend `InboundMessage` with button interaction fields from Twilio webhooks. When a user taps an RCS/rich messaging quick-reply button, Twilio sends `ButtonPayload` (the button `id`) and `ButtonText` (the button `title`) as webhook params. The `Body` field also contains the button text, so the LLM naturally handles it:

```typescript
export interface InboundMessage {
  messageSid: string;
  from: string;
  to: string;
  body: string;
  numMedia: number;
  buttonPayload: string | null;
  buttonText: string | null;
}
```

**src/messaging/twilio-provider.ts:**

Update `send()` to handle the two mutually exclusive modes:
- If `message.contentSid` is present: pass `contentSid`, `contentVariables`, and `messagingServiceSid` (required for content template sends). Do NOT include `body`.
- If `message.body` is present (existing behavior): pass `body` with either `messagingServiceSid` or `from`.

```typescript
async send(message: OutboundMessage): Promise<SendResult> {
  if (message.contentSid) {
    // Rich card via Content Template
    const result = await this.client.messages.create({
      contentSid: message.contentSid,
      ...(message.contentVariables ? { contentVariables: message.contentVariables } : {}),
      to: message.to,
      ...(message.messagingServiceSid
        ? { messagingServiceSid: message.messagingServiceSid }
        : { from: message.from }),
    });
    return { sid: result.sid, status: result.status };
  }

  // Plain text (existing behavior)
  const result = await this.client.messages.create({
    body: message.body ?? "",
    to: message.to,
    ...(message.messagingServiceSid
      ? { messagingServiceSid: message.messagingServiceSid }
      : { from: message.from }),
  });
  return { sid: result.sid, status: result.status };
}
```

Update `parseInbound()` to extract button fields:

```typescript
parseInbound(body: Record<string, string>): InboundMessage {
  return {
    messageSid: body.MessageSid ?? "",
    from: body.From ?? "",
    to: body.To ?? "",
    body: body.Body ?? "",
    numMedia: Number.parseInt(body.NumMedia ?? "0", 10),
    buttonPayload: body.ButtonPayload ?? null,
    buttonText: body.ButtonText ?? null,
  };
}
```

No other changes needed in `MessagingProvider` interface -- `send()` signature uses `OutboundMessage` which already covers the new fields.
  </action>
  <verify>Run `npx tsc --noEmit` -- no type errors. Verify that all existing `messaging.send()` calls throughout the codebase still compile (they pass `body` + `from`, which is still valid).</verify>
  <done>OutboundMessage supports contentSid/contentVariables, InboundMessage includes buttonPayload/buttonText, TwilioMessagingProvider handles both send modes and parses button fields.</done>
</task>

<task type="auto">
  <name>Task 2: Create content template management module</name>
  <files>src/messaging/content-templates.ts</files>
  <action>
Create `src/messaging/content-templates.ts` with utilities for creating and managing Twilio Content Templates via the REST API. The Twilio Node SDK does not have complete helper methods for Content Template card creation, so use native `fetch()` following the project's zero-dependency API client pattern.

**Functions to create:**

1. `createSearchResultTemplate(accountSid: string, authToken: string): Promise<string>` -- Creates a search result card template with 4 variables (title, year, overview, posterUrl) and 3 quick-reply buttons ("Add this", "Next result", "Check Plex"). Returns the ContentSid (HXxxxx format). Template includes both `twilio/card` (for RCS/rich) and `twilio/text` (for SMS fallback).

Template structure:
```typescript
{
  friendly_name: "wadsmedia_search_result",
  language: "en",
  variables: {
    "1": "Title",
    "2": "Year",
    "3": "Overview text...",
    "4": "https://image.tmdb.org/t/p/w500/placeholder.jpg",
  },
  types: {
    "twilio/card": {
      title: "{{1}} ({{2}})",
      body: "{{3}}",
      media: ["{{4}}"],
      actions: [
        { type: "QUICK_REPLY", title: "Add this", id: "add_media" },
        { type: "QUICK_REPLY", title: "Next result", id: "next_result" },
        { type: "QUICK_REPLY", title: "Check Plex", id: "check_plex" },
      ],
    },
    "twilio/text": {
      body: "{{1}} ({{2}})\n{{3}}",
    },
  },
}
```

2. `createSearchResultTextOnlyTemplate(accountSid: string, authToken: string): Promise<string>` -- A fallback template for results without poster images. Same as above but without the `media` field in `twilio/card`. This handles null posterUrl gracefully.

3. `getTemplate(accountSid: string, authToken: string, contentSid: string): Promise<ContentTemplate | null>` -- Fetches a template by SID to verify it exists. Returns null on 404.

4. `listTemplates(accountSid: string, authToken: string): Promise<ContentTemplate[]>` -- Lists all content templates. Useful for finding existing templates by friendly_name to avoid recreation.

5. `ensureSearchResultTemplate(accountSid: string, authToken: string): Promise<string>` -- Idempotent helper: lists templates, finds one with friendly_name "wadsmedia_search_result", returns its SID. If not found, creates it and returns the new SID. This is the primary entry point for the engine.

**Type definitions (in the same file):**
```typescript
interface ContentTemplate {
  sid: string;
  friendly_name: string;
  language: string;
  date_created: string;
  date_updated: string;
}
```

**API details:**
- Base URL: `https://content.twilio.com/v1/Content`
- Auth: Basic auth with `accountSid:authToken` base64 encoded
- Content-Type: `application/json`

**Important:** All button titles must be under 20 characters (RCS limit). Current titles: "Add this" (8), "Next result" (11), "Check Plex" (10) -- all safe.
  </action>
  <verify>Run `npx tsc --noEmit` -- no type errors. The module exports the expected functions. Manual verification of API calls will happen in Plan 13-02 integration.</verify>
  <done>Content template creation, retrieval, and idempotent ensure functions exist, using native fetch() to Twilio Content REST API with proper Basic auth.</done>
</task>

<task type="auto">
  <name>Task 3: Add posterUrl to search_movies and search_series results</name>
  <files>
    src/conversation/tools/search-movies.ts
    src/conversation/tools/search-series.ts
  </files>
  <action>
Both Radarr and Sonarr search results include an `images` array with objects like `{ coverType: "poster", remoteUrl: "https://..." }`. Extract the poster URL and include it in the tool output so the engine can build rich cards.

**src/conversation/tools/search-movies.ts:**

In the `.map()` callback that builds results, add `posterUrl` extraction:

```typescript
const results = searchResults.slice(0, 10).map((movie) => {
  const libraryMovie = libraryMovieMap.get(movie.tmdbId);
  // Extract poster URL from images array
  const posterImage = movie.images?.find((img) => img.coverType === "poster");
  return {
    title: movie.title,
    year: movie.year,
    tmdbId: movie.tmdbId,
    overview:
      movie.overview && movie.overview.length > 150
        ? `${movie.overview.slice(0, 150)}...`
        : movie.overview,
    inLibrary: !!libraryMovie,
    libraryId: libraryMovie?.id ?? null,
    status: movie.status,
    studio: movie.studio ?? null,
    posterUrl: posterImage?.remoteUrl ?? null,
  };
});
```

**src/conversation/tools/search-series.ts:**

Same pattern:

```typescript
const results = searchResults.slice(0, 10).map((series) => {
  const librarySerie = librarySeriesMap.get(series.tvdbId);
  // Extract poster URL from images array
  const posterImage = series.images?.find((img) => img.coverType === "poster");
  return {
    title: series.title,
    year: series.year,
    tvdbId: series.tvdbId,
    network: series.network ?? null,
    seasonCount: series.seasons.length,
    overview:
      series.overview && series.overview.length > 150
        ? `${series.overview.slice(0, 150)}...`
        : series.overview,
    inLibrary: !!librarySerie,
    libraryId: librarySerie?.id ?? null,
    status: series.status,
    posterUrl: posterImage?.remoteUrl ?? null,
  };
});
```

Note: The `images` array is already parsed by the Zod schemas (both `radarr.schemas.ts` and `sonarr.schemas.ts` include `images: z.array(ImageSchema)`). The `ImageSchema` validates `coverType: z.string()` and `remoteUrl: z.string().optional()`. No schema changes needed.

The `discover_media` tool already includes `posterUrl` via `tmdbImageUrl()` -- no changes needed there.
  </action>
  <verify>Run `npx tsc --noEmit` -- no type errors. Verify that both search tools now have `posterUrl` in their return objects. Run `npm test` if tests exist for these tools.</verify>
  <done>search_movies and search_series tool results include posterUrl extracted from Radarr/Sonarr images array, making all search-type tools rich-card-ready.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `OutboundMessage` type has both `body?` and `contentSid?` fields
3. `InboundMessage` type has `buttonPayload` and `buttonText` fields
4. `TwilioMessagingProvider.send()` branches on contentSid presence
5. `content-templates.ts` exports `ensureSearchResultTemplate`, `createSearchResultTemplate`, `getTemplate`, `listTemplates`
6. `search-movies.ts` result objects include `posterUrl`
7. `search-series.ts` result objects include `posterUrl`
8. All existing `messaging.send({ body, from })` calls still compile
</verification>

<success_criteria>
- Messaging types support both plain text and content template sends
- Inbound messages capture button interactions
- Content template management module exists with idempotent template creation
- All three search-type tools (search_movies, search_series, discover_media) include posterUrl in results
- No regressions in existing send behavior
</success_criteria>

<output>
After completion, create `.planning/phases/13-rcs-rich-messaging-personality/13-01-SUMMARY.md`
</output>
