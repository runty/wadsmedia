---
phase: 14-provider-generalization-sms-polish
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema.ts
  - src/users/user.service.ts
  - src/users/user.types.ts
  - drizzle/0005_*.sql
autonomous: true

must_haves:
  truths:
    - "Users table has telegramChatId column (nullable, unique)"
    - "Users table has telegramUsername column (nullable)"
    - "Users table phone column is nullable (Telegram-only users won't have a phone)"
    - "Drizzle migration file exists that adds telegram columns and makes phone nullable"
    - "user.service.ts has findUserByTelegramChatId function"
  artifacts:
    - path: "src/db/schema.ts"
      provides: "Users table with telegramChatId and telegramUsername columns"
      contains: "telegramChatId"
    - path: "src/users/user.service.ts"
      provides: "User service with findUserByTelegramChatId"
      exports: ["findUserByTelegramChatId"]
    - path: "drizzle"
      provides: "Migration SQL adding telegram columns"
  key_links:
    - from: "src/users/user.service.ts"
      to: "src/db/schema.ts"
      via: "imports users table, queries by telegramChatId"
      pattern: "users\\.telegramChatId"
    - from: "src/users/user.types.ts"
      to: "src/db/schema.ts"
      via: "infers User type from users table"
      pattern: "users\\.\\$inferSelect"
---

<objective>
Add Telegram identity columns to the users table and prepare user service for multi-provider identity resolution.

Purpose: Phase 15 (Telegram DM) needs to resolve users by Telegram chat ID. This plan adds the schema columns and query function so Phase 15 can focus on Telegram integration without schema work. Making phone nullable allows future Telegram-only users who never interact via SMS.
Output: Updated schema with migration, findUserByTelegramChatId in user service.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@src/db/schema.ts
@src/users/user.service.ts
@src/users/user.types.ts
@drizzle.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update users table schema and generate migration</name>
  <files>src/db/schema.ts</files>
  <action>
Update the `users` table definition in src/db/schema.ts:

1. **Make `phone` nullable.** Change from:
```typescript
phone: text("phone").notNull().unique(),
```
to:
```typescript
phone: text("phone").unique(),
```
This removes the `.notNull()` constraint. Existing rows all have phone values so this is safe. The unique constraint stays (two users can't share a phone). Telegram-only users created in Phase 15 will have `phone: null`.

2. **Add `telegramChatId` column:**
```typescript
telegramChatId: text("telegram_chat_id").unique(),
```
Nullable (SMS users won't have it), unique (each Telegram chat maps to one user).

3. **Add `telegramUsername` column:**
```typescript
telegramUsername: text("telegram_username"),
```
Nullable, not unique (Telegram usernames can change and aren't guaranteed).

Place the new columns after `phone` for logical grouping:
```typescript
export const users = sqliteTable("users", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  phone: text("phone").unique(),
  telegramChatId: text("telegram_chat_id").unique(),
  telegramUsername: text("telegram_username"),
  displayName: text("display_name"),
  status: text("status", { enum: ["active", "pending", "blocked"] })
    .notNull()
    .default("pending"),
  isAdmin: integer("is_admin", { mode: "boolean" }).notNull().default(false),
  createdAt: integer("created_at", { mode: "timestamp" })
    .notNull()
    .$defaultFn(() => new Date()),
  plexUserId: integer("plex_user_id"),
  updatedAt: integer("updated_at", { mode: "timestamp" })
    .notNull()
    .$defaultFn(() => new Date()),
});
```

After editing the schema, generate the migration:
```bash
npx drizzle-kit generate
```

This creates a new SQL migration file in `drizzle/` (will be named something like `0005_*.sql`). Verify the generated SQL contains:
- `ALTER TABLE users ADD telegram_chat_id text;`
- `ALTER TABLE users ADD telegram_username text;`
- A unique index on telegram_chat_id

Note: SQLite does not support `ALTER TABLE ... ALTER COLUMN` to drop NOT NULL. The phone column change (removing NOT NULL) requires Drizzle to handle it. Check the generated migration. If Drizzle generates a table recreation (CREATE new table, copy data, drop old, rename), that's fine -- it's the standard SQLite approach for column constraint changes. If Drizzle does NOT handle the NOT NULL removal (some versions skip it for SQLite), we may need to add a manual migration step. Verify the generated SQL carefully.

If the generated migration does NOT drop the NOT NULL on phone, create a custom migration SQL file manually that:
1. Creates a new table without NOT NULL on phone
2. Copies data
3. Drops old table
4. Renames new table

However, checking Drizzle behavior: `drizzle-kit generate` for SQLite typically handles this via table recreation. Verify the output.
  </action>
  <verify>
- `grep "telegramChatId" src/db/schema.ts` returns matches
- `grep "telegramUsername" src/db/schema.ts` returns matches
- `grep "notNull" src/db/schema.ts | grep "phone"` returns NO matches (phone is nullable)
- `ls drizzle/0005_*.sql` exists
- `cat drizzle/0005_*.sql` contains telegram_chat_id
- `npx tsc --noEmit 2>&1 | head -20` -- check for type errors (User type will auto-update since it's inferred from schema)
  </verify>
  <done>
Users table schema has telegramChatId (unique, nullable) and telegramUsername (nullable) columns. Phone is nullable. Drizzle migration generated and ready to apply on next server start.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add findUserByTelegramChatId to user service</name>
  <files>src/users/user.service.ts</files>
  <action>
Add a new query function to src/users/user.service.ts:

```typescript
export function findUserByTelegramChatId(db: DB, telegramChatId: string) {
  return db.select().from(users).where(eq(users.telegramChatId, telegramChatId)).get();
}
```

This follows the exact same pattern as the existing `findUserByPhone` function. It will be used by Phase 15's Telegram webhook handler to resolve incoming messages to users.

Also update `createUser` and `upsertUser` to accept optional `telegramChatId` and `telegramUsername` fields:

```typescript
export function createUser(
  db: DB,
  phone: string | null,
  opts?: {
    displayName?: string;
    status?: UserStatus;
    isAdmin?: boolean;
    telegramChatId?: string;
    telegramUsername?: string;
  },
) {
  return db
    .insert(users)
    .values({
      phone,
      telegramChatId: opts?.telegramChatId,
      telegramUsername: opts?.telegramUsername,
      displayName: opts?.displayName,
      status: opts?.status ?? "pending",
      isAdmin: opts?.isAdmin ?? false,
    })
    .returning()
    .get();
}
```

Update `upsertUser` similarly -- accept `telegramChatId` and `telegramUsername` in opts. Note: upsertUser currently uses `onConflictDoUpdate` on `users.phone` target. This works for phone-based upserts. For Telegram-based upserts (Phase 15), a separate `upsertUserByTelegramChatId` may be needed, but that's Phase 15 scope. For now, just add the fields to the opts and values.

Also update `updateUserStatus` and `updateDisplayName` -- these currently query by phone. Since phone is now nullable, these functions should accept a user ID instead of phone for reliability. However, changing the signature would break callers (onboarding.ts uses them with phone). For backward compatibility, keep the phone-based versions AND add ID-based alternatives:

```typescript
export function updateUserStatusById(db: DB, userId: number, status: UserStatus) {
  return db
    .update(users)
    .set({ status, updatedAt: new Date() })
    .where(eq(users.id, userId))
    .returning()
    .get();
}

export function updateDisplayNameById(db: DB, userId: number, displayName: string) {
  return db
    .update(users)
    .set({ displayName, updatedAt: new Date() })
    .where(eq(users.id, userId))
    .returning()
    .get();
}
```

Keep the existing phone-based versions for now (onboarding.ts still uses them for SMS users). Phase 15 will migrate onboarding to use ID-based versions when adding Telegram onboarding.

Verify that `npm run build` succeeds and `npm run check` passes after these changes. The User type (inferred from schema) automatically gains the new nullable fields, so user.types.ts needs no manual changes.
  </action>
  <verify>
- `grep "findUserByTelegramChatId" src/users/user.service.ts` returns a match
- `grep "telegramChatId" src/users/user.service.ts` returns matches
- `grep "updateDisplayNameById" src/users/user.service.ts` returns a match
- `npx tsc --noEmit` compiles cleanly (no type errors from User type change)
- `npm run build` succeeds
- `npm run check` passes (Biome linting)
  </verify>
  <done>
User service has findUserByTelegramChatId for Phase 15. createUser and upsertUser accept Telegram fields. ID-based update functions added for provider-agnostic user updates. All types compile cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds
2. `npm run check` passes
3. `ls drizzle/0005_*.sql` exists (migration generated)
4. Schema has telegramChatId, telegramUsername columns
5. Phone column is nullable in schema
6. findUserByTelegramChatId exists in user service
7. User type (inferred) automatically includes new fields
</verification>

<success_criteria>
User model supports optional Telegram identity alongside phone number. Migration is generated and will auto-apply on next server start. User service has queries for Telegram chat ID lookup. Phase 15 can build Telegram user resolution on this foundation.
</success_criteria>

<output>
After completion, create `.planning/phases/14-provider-generalization-sms-polish/14-03-SUMMARY.md`
</output>
