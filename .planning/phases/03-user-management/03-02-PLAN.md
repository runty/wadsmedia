---
phase: 03-user-management
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/users/onboarding.ts
  - src/plugins/webhook.ts
  - src/config.ts
autonomous: true

must_haves:
  truths:
    - "Unknown phone numbers trigger a name prompt when they first text the app"
    - "After providing their name, the admin receives a text asking to approve the new user"
    - "Pending users who text again receive a 'waiting for approval' message"
    - "Known active users pass through to normal message handling"
    - "Admin phone is always treated as active regardless of whitelist"
    - "Users whose phones appear in PHONE_WHITELIST on restart are auto-promoted to active"
  artifacts:
    - path: "src/users/onboarding.ts"
      provides: "Onboarding state machine: handleOnboarding function that routes based on user status"
      exports: ["handleOnboarding"]
    - path: "src/plugins/webhook.ts"
      provides: "Updated webhook handler using resolveUser preHandler and routing through onboarding for non-active users"
      contains: "fastify.resolveUser"
    - path: "src/config.ts"
      provides: "ADMIN_PHONE marked as required for Phase 3+ (system needs admin for approval notifications)"
      contains: "ADMIN_PHONE"
  key_links:
    - from: "src/plugins/webhook.ts"
      to: "src/plugins/user-resolver.ts"
      via: "uses fastify.resolveUser as preHandler on POST /webhook/twilio"
      pattern: "preHandler.*resolveUser"
    - from: "src/plugins/webhook.ts"
      to: "src/users/onboarding.ts"
      via: "calls handleOnboarding for non-active users"
      pattern: "handleOnboarding"
    - from: "src/users/onboarding.ts"
      to: "src/users/user.service.ts"
      via: "calls updateDisplayName to store user's name"
      pattern: "updateDisplayName"
    - from: "src/users/onboarding.ts"
      to: "fastify.messaging.send"
      via: "sends admin notification about new user"
      pattern: "messaging\\.send"
---

<objective>
Implement the unknown user onboarding flow and wire the user-resolver into the webhook handler. When an unknown number texts, the system asks for their name, stores it, notifies the admin, and replies with a "pending approval" message on subsequent texts. Active users pass through to normal handling.

Purpose: Completes the user management lifecycle -- the system now handles every possible user state (unknown, pending, active, blocked) and routes messages accordingly. This is the last piece before Phase 5 adds actual conversation logic.
Output: Onboarding module, updated webhook handler with user routing, ADMIN_PHONE required in config.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-user-management/03-RESEARCH.md
@.planning/phases/03-user-management/03-01-SUMMARY.md
@src/plugins/webhook.ts
@src/config.ts
@src/messaging/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Onboarding state machine module</name>
  <files>src/users/onboarding.ts</files>
  <action>
Create `src/users/onboarding.ts` -- a pure module containing the onboarding state machine logic.

Export a single function `handleOnboarding` with this signature:
```typescript
export async function handleOnboarding(params: {
  user: User;
  messageBody: string;
  db: BetterSQLite3Database<typeof schema>;
  messaging: MessagingProvider;
  config: AppConfig;
  log: FastifyBaseLogger;
}): Promise<string>
```

Returns the text reply to send back to the user.

State machine logic based on `user.status`:

**Case "pending" with NO displayName (first contact from unknown number):**
- Reply: "Welcome! I don't recognize your number. What's your name?"
- No other action -- user record already created as "pending" by the resolver

**Case "pending" with NO displayName AND messageBody is not empty (second message -- user providing their name):**
- Wait -- this case is tricky. We need to distinguish "first ever message" from "user responding with their name." Since both arrive with status "pending" and displayName null, use the following approach:
  - On the FIRST message from an unknown number, the resolver creates a pending user. The onboarding function sees pending + no displayName and replies asking for name. The user's actual first message content is ignored for onboarding purposes (they were trying to use the app, not answer a question).
  - On the SECOND message, the user is responding with their name. Status is still "pending", displayName is still null. But we need to differentiate.
  - Solution: Check if user was JUST created (createdAt is very recent, within last few seconds) vs. has existed for a while. This is fragile.
  - Better solution: Use a separate approach -- when the user first texts and has no displayName, set displayName to empty string "" (not null) to mark "we've asked for their name." On the next message, displayName is "" (empty string, not null), meaning they should now be providing their name.

Revised state machine:

**Case: user.status === "pending" AND user.displayName === null (brand new unknown user):**
- Call `updateDisplayName(db, user.phone, "")` -- mark as "asked for name" (empty string, not null)
- Return: "Hey there! I don't recognize your number. What's your name?"

**Case: user.status === "pending" AND user.displayName === "" (asked for name, awaiting response):**
- The messageBody IS their name. Trim it and take the first 50 chars.
- If trimmed name is empty (blank message), return: "I need a name to set up your account. What should I call you?"
- Call `updateDisplayName(db, user.phone, trimmedName)`
- Send admin notification via `messaging.send()`:
  - to: `config.ADMIN_PHONE` (guaranteed to exist, required in config)
  - body: `New user request: ${trimmedName} (${user.phone}). Add their number to PHONE_WHITELIST to approve.`
  - from: `config.TWILIO_PHONE_NUMBER`
- Log: `{ phone: user.phone, name: trimmedName }` "New user onboarding: admin notified"
- Return: `Thanks ${trimmedName}! I've sent a request to the admin for approval. You'll be able to use the app once approved.`

**Case: user.status === "pending" AND user.displayName is a non-empty string (name given, waiting for approval):**
- Return: `Hi ${user.displayName}, your access request is still pending approval. Hang tight!`

**Case: user.status === "blocked":**
- Return: "Sorry, your access has been revoked. Contact the admin if you believe this is an error."

**Case: user.status === "active":**
- This should NOT reach handleOnboarding (webhook handler routes active users differently). But as a safety net, return null or throw -- let the caller handle it.
- Actually, return `null` to signal "no onboarding needed, proceed normally."

Import types:
- `User` from `./user.types.js`
- `updateDisplayName` from `./user.service.js`
- `MessagingProvider` from `../messaging/types.js`
- `AppConfig` from `../config.js`
- DB type from drizzle-orm/better-sqlite3
- `FastifyBaseLogger` from `fastify`
  </action>
  <verify>
- `npx tsc --noEmit` passes with no type errors
- `npm run check` (Biome) passes
  </verify>
  <done>
- `src/users/onboarding.ts` exports `handleOnboarding` function
- Function handles all user states: new unknown (asks name), name pending (stores name, notifies admin), approval pending (waiting message), blocked (denied message)
- Admin notification sent via messaging.send() with user name and phone
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire user resolver and onboarding into webhook handler</name>
  <files>src/plugins/webhook.ts, src/config.ts</files>
  <action>
1. Update `src/config.ts`:
   - Change `ADMIN_PHONE` from `.optional()` to required: `z.string().min(1)`
   - Update the comment: "Users (required starting Phase 3)"
   - Keep `PHONE_WHITELIST` optional (no change)

2. Rewrite `src/plugins/webhook.ts` to add user resolution and onboarding routing:
   - Keep the existing `validateTwilioSignature` preHandler unchanged
   - Add `fastify.resolveUser` as a second preHandler (runs after signature validation):
     ```
     preHandler: [validateTwilioSignature, fastify.resolveUser]
     ```
   - Update the route handler logic:
     ```typescript
     async (request, reply) => {
       const message = fastify.messaging.parseInbound(request.body as Record<string, string>);
       request.log.info({ from: message.from, body: message.body }, "Incoming message");

       const user = request.user;

       // If user resolution failed (no From field), acknowledge silently
       if (!user) {
         return reply.type("text/xml").send(fastify.messaging.formatEmptyReply());
       }

       // Active users: pass through to normal handling (future phases add conversation logic here)
       if (user.status === "active") {
         // Phase 3: acknowledge receipt; Phase 5+ adds conversation engine
         const replyText = `Message received, ${user.displayName || "friend"}. Conversation features coming soon!`;
         return reply.type("text/xml").send(fastify.messaging.formatReply(replyText));
       }

       // Non-active users: route through onboarding
       const onboardingReply = await handleOnboarding({
         user,
         messageBody: message.body,
         db: fastify.db,
         messaging: fastify.messaging,
         config: fastify.config,
         log: request.log,
       });

       if (onboardingReply) {
         return reply.type("text/xml").send(fastify.messaging.formatReply(onboardingReply));
       }

       // Fallback (should not reach here)
       return reply.type("text/xml").send(fastify.messaging.formatEmptyReply());
     }
     ```
   - Import `handleOnboarding` from `../users/onboarding.js`
   - Update plugin dependencies to include "user-resolver": `{ name: "webhook", dependencies: ["messaging", "user-resolver"] }`

Note on ADMIN_PHONE becoming required: This is a breaking change for Phase 1/2 where it was optional. Since we're pre-release and the app is not deployed yet, this is acceptable. The docker-compose.yml already has an env_file reference; users just need to add ADMIN_PHONE to their .env file. The server will fail fast on startup with a clear Zod validation error if ADMIN_PHONE is missing.
  </action>
  <verify>
- `npx tsc --noEmit` passes with no type errors
- `npm run check` (Biome) passes
- `npm run build` succeeds (full compilation)
- Application starts successfully with ADMIN_PHONE set (test with `ADMIN_PHONE=+15551234567 npm run dev`)
  </verify>
  <done>
- `src/config.ts` has ADMIN_PHONE as required
- `src/plugins/webhook.ts` uses both validateTwilioSignature and fastify.resolveUser as preHandlers
- Active users receive acknowledgment with their display name
- Non-active users are routed through the onboarding state machine
- Blocked users receive a denial message
- Pending users receive appropriate messages based on their onboarding state
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` -- no type errors across entire project
- `npm run check` -- Biome lint/format passes
- `npm run build` -- full compilation succeeds
- Application starts with ADMIN_PHONE and PHONE_WHITELIST set:
  - Admin user seeded as active with isAdmin=true
  - Whitelist users seeded as active
- Webhook handler resolves users from phone number on every request
- Unknown numbers receive onboarding prompt, provide name, admin gets notified
- Pending users get "waiting for approval" on subsequent messages
- Active users get acknowledgment message
</verification>

<success_criteria>
- Complete user lifecycle works: unknown -> asked name -> name stored + admin notified -> pending -> approved (via whitelist on restart)
- Admin always designated and seeded from ADMIN_PHONE env var
- Webhook handler never processes messages without resolving a user first
- Per-user data isolation established via user.id foreign key (ready for Phase 5 conversations table)
- No new npm dependencies required
</success_criteria>

<output>
After completion, create `.planning/phases/03-user-management/03-02-SUMMARY.md`
</output>
