---
phase: 03-user-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema.ts
  - src/users/user.service.ts
  - src/users/user.types.ts
  - src/plugins/user-resolver.ts
  - src/server.ts
autonomous: true

must_haves:
  truths:
    - "Admin user is designated via environment variable and seeded as active on startup"
    - "Known users on the phone number whitelist are seeded as active on startup"
    - "Every webhook request has a resolved user attached to request.user"
    - "Each user has a stored display name associated with their phone number"
  artifacts:
    - path: "src/db/schema.ts"
      provides: "users table definition with phone, displayName, status, isAdmin columns"
      contains: "export const users = sqliteTable"
    - path: "src/users/user.service.ts"
      provides: "User CRUD operations: findByPhone, createUser, updateStatus, updateDisplayName, upsertUser"
      exports: ["findUserByPhone", "createUser", "updateUserStatus", "updateDisplayName", "upsertUser"]
    - path: "src/users/user.types.ts"
      provides: "User and NewUser type exports inferred from schema"
      exports: ["User", "NewUser", "UserStatus"]
    - path: "src/plugins/user-resolver.ts"
      provides: "Fastify plugin that seeds admin/whitelist users on startup, decorates request with user, and exposes resolveUser preHandler"
      exports: ["default", "resolveUser"]
  key_links:
    - from: "src/plugins/user-resolver.ts"
      to: "src/users/user.service.ts"
      via: "import and call upsertUser/findUserByPhone"
      pattern: "import.*from.*user\\.service"
    - from: "src/plugins/user-resolver.ts"
      to: "src/db/schema.ts"
      via: "uses users table through user service"
      pattern: "upsertUser|findUserByPhone"
    - from: "src/server.ts"
      to: "src/plugins/user-resolver.ts"
      via: "plugin registration before webhook"
      pattern: "register\\(userResolverPlugin\\)"
    - from: "src/plugins/user-resolver.ts"
      to: "fastify.config.ADMIN_PHONE"
      via: "reads admin phone from config to seed admin user"
      pattern: "fastify\\.config\\.ADMIN_PHONE"
---

<objective>
Create the users data layer, user service module, and user-resolver Fastify plugin. On startup, the admin phone and whitelist phones are seeded into the database as active users. On each webhook request, the inbound phone number is resolved to a user record attached to `request.user`.

Purpose: Establishes the user identity foundation that all subsequent phases depend on. Without user resolution, the system cannot authorize, onboard, or isolate data per user.
Output: users table with migration, user service module, user-resolver plugin registered in the Fastify server.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-user-management/03-RESEARCH.md
@src/db/schema.ts
@src/db/index.ts
@src/config.ts
@src/server.ts
@src/plugins/database.ts
@src/plugins/messaging.ts
@src/messaging/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Users table schema and user service module</name>
  <files>src/db/schema.ts, src/users/user.service.ts, src/users/user.types.ts</files>
  <action>
1. Extend `src/db/schema.ts` -- add a `users` table after the existing `appMetadata` table:
   - `id`: integer primary key, autoIncrement
   - `phone`: text, notNull, unique (E.164 format from Twilio)
   - `displayName`: text (nullable -- set during onboarding)
   - `status`: text with enum ["active", "pending", "blocked"], notNull, default "pending"
   - `isAdmin`: integer mode boolean, notNull, default false
   - `createdAt`: integer mode timestamp, notNull, $defaultFn(() => new Date())
   - `updatedAt`: integer mode timestamp, notNull, $defaultFn(() => new Date())

2. Create `src/users/user.types.ts`:
   - Export `User` type as `typeof users.$inferSelect`
   - Export `NewUser` type as `typeof users.$inferInsert`
   - Export `UserStatus` type as `"active" | "pending" | "blocked"`

3. Create `src/users/user.service.ts` -- pure functions taking `db` as first argument (dependency injection, matching codebase pattern):
   - `findUserByPhone(db, phone)` -- select from users where phone equals, returns User | undefined
   - `createUser(db, phone, opts?: { displayName?, status?, isAdmin? })` -- insert and return, uses .returning().get()
   - `upsertUser(db, phone, opts?)` -- insert with onConflictDoUpdate on phone target, sets status and updatedAt on conflict, returns User
   - `updateUserStatus(db, phone, status)` -- update status and updatedAt, returns User | undefined via .returning().get()
   - `updateDisplayName(db, phone, displayName)` -- update displayName and updatedAt, returns User | undefined via .returning().get()
   - Use `eq` from `drizzle-orm` for where clauses
   - The DB type parameter should be `BetterSQLite3Database<typeof schema>` imported from drizzle-orm/better-sqlite3, with `* as schema` from the schema file

4. Generate the migration: run `npm run db:generate` to create migration SQL for the new users table. The existing auto-migration on startup will apply it.

Note: Import users table from `../db/schema.js` (ESM .js extension pattern established in codebase).
  </action>
  <verify>
- `npx tsc --noEmit` passes with no type errors
- `npm run db:generate` succeeds and creates a new migration file in `drizzle/`
- `npm run check` (Biome) passes
  </verify>
  <done>
- `src/db/schema.ts` exports `users` table with all specified columns
- `src/users/user.types.ts` exports User, NewUser, and UserStatus types
- `src/users/user.service.ts` exports findUserByPhone, createUser, upsertUser, updateUserStatus, updateDisplayName functions
- A new migration SQL file exists in `drizzle/` directory for the users table
  </done>
</task>

<task type="auto">
  <name>Task 2: User-resolver Fastify plugin with startup seeding</name>
  <files>src/plugins/user-resolver.ts, src/server.ts</files>
  <action>
1. Create `src/plugins/user-resolver.ts` as a Fastify plugin using `fp()` wrapper:
   - Plugin name: "user-resolver", dependencies: ["database"]
   - Augment FastifyRequest interface: add `user: User | null` (import User from user.types.ts)
   - Call `fastify.decorateRequest("user", null)` -- null for reference type (Fastify pattern for avoiding shared state)

   Startup seeding logic (runs once during plugin registration):
   - If `fastify.config.ADMIN_PHONE` is set: upsert user with phone=ADMIN_PHONE, status="active", isAdmin=true. Log: "Admin user seeded: {phone}"
   - If `fastify.config.PHONE_WHITELIST` is set (array of strings): iterate and upsert each phone with status="active". Log: "Whitelisted user seeded: {phone}". If a phone matches ADMIN_PHONE, skip (already seeded as admin with isAdmin=true)

   Export a named `resolveUser` preHandler function (NOT a global hook -- webhook plugin will use it at the route level):
   - Extract phone from parsed request body: `(request.body as Record<string, string>).From`
   - If no From field, log warning and set request.user = null, return (let handler decide)
   - Call `findUserByPhone(fastify.db, phone)`
   - If found: set `request.user = user`
   - If not found: create a new user with `createUser(fastify.db, phone, { status: "pending" })`, set `request.user = newUser`
   - The resolveUser function needs access to `fastify` instance. Export it as a factory: the plugin assigns it to `fastify.resolveUser` via decorate, OR export a function that creates the preHandler bound to the fastify instance. Preferred approach: define within plugin and add to fastify via `fastify.decorate("resolveUser", resolveUserHandler)` so webhook can access `fastify.resolveUser` as a preHandler.

   Augment FastifyInstance to include resolveUser:
   ```
   declare module "fastify" {
     interface FastifyInstance {
       resolveUser: (request: FastifyRequest, reply: FastifyReply) => Promise<void>;
     }
   }
   ```

2. Update `src/server.ts`:
   - Import `userResolverPlugin` from `./plugins/user-resolver.js`
   - Register it AFTER databasePlugin and BEFORE webhookPlugin (order matters -- webhook needs resolveUser available):
     ```
     await fastify.register(databasePlugin);
     await fastify.register(healthPlugin);
     await fastify.register(formbody);
     await fastify.register(messagingPlugin);
     await fastify.register(userResolverPlugin);  // <-- add here
     await fastify.register(webhookPlugin);
     ```

Note: Do NOT modify webhook.ts in this plan -- that is handled in plan 03-02.
  </action>
  <verify>
- `npx tsc --noEmit` passes with no type errors
- `npm run check` (Biome) passes
- `npm run dev` starts successfully (test with `timeout 5 npm run dev` or similar) and logs show "Admin user seeded" when ADMIN_PHONE is set
  </verify>
  <done>
- `src/plugins/user-resolver.ts` exists with plugin registration, request decoration, startup seeding, and resolveUser preHandler
- `src/server.ts` registers userResolverPlugin in correct order (after database, before webhook)
- `fastify.resolveUser` is available as a preHandler for route-level use
- Admin and whitelist phones are seeded as active users on startup
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- `npm run check` passes
- `npm run db:generate` has produced migration for users table
- Application starts without errors (migrations auto-apply on startup)
- Admin user record exists in database after startup when ADMIN_PHONE is configured
</verification>

<success_criteria>
- Users table exists in SQLite with correct schema (phone unique, status enum, isAdmin boolean, timestamps)
- User service provides complete CRUD operations with proper TypeScript types
- User-resolver plugin seeds admin and whitelist users on startup
- Every webhook request can have a user resolved via `fastify.resolveUser` preHandler
- No new npm dependencies needed (all libraries already installed)
</success_criteria>

<output>
After completion, create `.planning/phases/03-user-management/03-01-SUMMARY.md`
</output>
