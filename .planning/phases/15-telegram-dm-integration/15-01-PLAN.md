---
phase: 15-telegram-dm-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/messaging/types.ts
  - src/messaging/telegram-provider.ts
  - src/plugins/telegram-messaging.ts
  - src/config.ts
  - src/server.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "TelegramMessagingProvider implements full MessagingProvider interface"
    - "Provider sends text via sendMessage and photos via sendPhoto with caption and inline keyboard"
    - "Webhook validation compares X-Telegram-Bot-Api-Secret-Token header against configured secret"
    - "Provider parses both message and callback_query Telegram Update types into InboundMessage"
    - "grammy Api class is used as typed HTTP client (NOT Bot class)"
  artifacts:
    - path: "src/messaging/telegram-provider.ts"
      provides: "TelegramMessagingProvider class"
      exports: ["TelegramMessagingProvider"]
    - path: "src/messaging/types.ts"
      provides: "Extended OutboundMessage with inlineKeyboard, photoUrl, parseMode"
      contains: "inlineKeyboard"
    - path: "src/plugins/telegram-messaging.ts"
      provides: "Fastify plugin that initializes TelegramMessagingProvider"
      exports: ["default"]
    - path: "src/config.ts"
      provides: "TELEGRAM_WEBHOOK_URL and ADMIN_TELEGRAM_CHAT_ID env vars"
      contains: "TELEGRAM_WEBHOOK_URL"
  key_links:
    - from: "src/plugins/telegram-messaging.ts"
      to: "src/messaging/telegram-provider.ts"
      via: "new TelegramMessagingProvider(botToken, webhookSecret)"
      pattern: "new TelegramMessagingProvider"
    - from: "src/server.ts"
      to: "src/plugins/telegram-messaging.ts"
      via: "fastify.register(telegramMessagingPlugin)"
      pattern: "telegramMessagingPlugin"
    - from: "src/messaging/telegram-provider.ts"
      to: "grammy"
      via: "import { Api } from 'grammy'"
      pattern: "Api"
---

<objective>
Build the TelegramMessagingProvider that implements the MessagingProvider interface using grammy's Api class, extend OutboundMessage types for Telegram-specific features (inline keyboards, photos, HTML parse mode), and register the provider as a Fastify plugin.

Purpose: This is the foundation for all Telegram communication. Every subsequent plan depends on having a working provider that can send/receive Telegram messages.

Output: TelegramMessagingProvider class, extended messaging types, Fastify plugin, updated config.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/messaging/types.ts
@src/messaging/twilio-provider.ts
@src/plugins/messaging.ts
@src/config.ts
@src/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install grammy and extend OutboundMessage types for Telegram features</name>
  <files>package.json, src/messaging/types.ts</files>
  <action>
Install grammy ^1.40.0: `npm install grammy`

Then extend src/messaging/types.ts:

1. Add an InlineButton interface:
```typescript
export interface InlineButton {
  text: string;           // Button label displayed to user
  callbackData: string;   // Callback data sent on tap (64 bytes max)
}
```

2. Add optional fields to OutboundMessage (after the existing mediaUrl field):
```typescript
/** Inline keyboard buttons (rows of buttons) */
inlineKeyboard?: InlineButton[][];
/** Photo URL to send with sendPhoto (Telegram) */
photoUrl?: string;
/** Parse mode for message formatting (Telegram: 'HTML') */
parseMode?: 'HTML';
```

These are provider-agnostic additions -- Twilio's send() will simply ignore them (it doesn't read these fields). This keeps the interface clean without Telegram-specific subtypes.

Do NOT create a TelegramOutboundMessage subtype -- the extra fields are optional and harmless on OutboundMessage.
  </action>
  <verify>
`npx tsc --noEmit` passes. The OutboundMessage interface includes inlineKeyboard, photoUrl, and parseMode as optional fields.
  </verify>
  <done>grammy is in package.json dependencies. OutboundMessage has InlineButton[][] inlineKeyboard, string photoUrl, and 'HTML' parseMode as optional fields.</done>
</task>

<task type="auto">
  <name>Task 2: Create TelegramMessagingProvider and Fastify plugin</name>
  <files>src/messaging/telegram-provider.ts, src/plugins/telegram-messaging.ts, src/config.ts, src/server.ts</files>
  <action>
**src/messaging/telegram-provider.ts** -- Create TelegramMessagingProvider implementing MessagingProvider:

```typescript
import { Api, InlineKeyboard } from "grammy";
import type { InboundMessage, MessagingProvider, OutboundMessage, SendResult, WebhookValidationParams } from "./types.js";

export class TelegramMessagingProvider implements MessagingProvider {
  readonly providerName = "telegram" as const;
  private api: Api;
  private webhookSecret: string;

  constructor(botToken: string, webhookSecret: string) {
    this.api = new Api(botToken);
    this.webhookSecret = webhookSecret;
  }
```

**send(message):**
- If message.photoUrl is set, use `this.api.sendPhoto(chatId, photoUrl, opts)` where opts includes:
  - caption: message.body (truncated to 1024 chars if needed -- Telegram caption limit)
  - parse_mode: message.parseMode or undefined
  - reply_markup: build InlineKeyboardMarkup from message.inlineKeyboard if present
- Else, use `this.api.sendMessage(chatId, body, opts)` where opts includes:
  - parse_mode: message.parseMode or undefined
  - reply_markup: InlineKeyboardMarkup from message.inlineKeyboard if present
- Build InlineKeyboardMarkup from message.inlineKeyboard by creating a grammy InlineKeyboard: for each row, call `.row()`, then for each button call `.text(button.text, button.callbackData)`
- Return SendResult with providerMessageId as `String(result.message_id)` and status "sent"

**validateWebhook(params):**
- Extract `x-telegram-bot-api-secret-token` from params.headers (case-insensitive -- headers object is lowercase in Fastify)
- Return `typeof token === "string" && token === this.webhookSecret`

**parseInbound(body):**
- Cast body as grammy's Update type (import from grammy/types)
- Handle two cases:
  a) message update (update.message exists): Extract from=String(update.message.chat.id), to="" (bot doesn't have a meaningful "to"), body=update.message.text ?? "", providerMessageId=String(update.message.message_id), numMedia=0, buttonPayload=null, buttonText=null
  b) callback_query update (update.callback_query exists): Extract from=String(update.callback_query.message?.chat.id ?? ""), body=update.callback_query.data ?? "", providerMessageId=String(update.callback_query.id), numMedia=0, buttonPayload=update.callback_query.data ?? null, buttonText=null
  c) Neither: Return a default InboundMessage with empty fields

**formatWebhookResponse():**
- Return null (Telegram does not reply via webhook response body)

**Telegram-specific public methods (not on MessagingProvider interface):**
- `async answerCallbackQuery(callbackQueryId: string, text?: string): Promise<void>` -- calls `this.api.answerCallbackQuery(callbackQueryId, { text })`
- `async sendChatAction(chatId: string, action: string): Promise<void>` -- calls `this.api.sendChatAction(chatId, action as any)`
- `async setWebhook(url: string, secretToken: string): Promise<void>` -- calls `this.api.setWebhook(url, { secret_token: secretToken })`
- `async getMe(): Promise<{ username: string }>` -- calls `this.api.getMe()` and returns `{ username: result.username ?? "" }`

**src/config.ts** -- Add two new env vars:
- `TELEGRAM_WEBHOOK_URL: z.string().url().optional()` -- Full webhook URL for setWebhook registration
- `ADMIN_TELEGRAM_CHAT_ID: z.string().min(1).optional()` -- Admin's Telegram chat ID for admin notifications

**src/plugins/telegram-messaging.ts** -- Fastify plugin:
- Check if TELEGRAM_BOT_TOKEN and TELEGRAM_WEBHOOK_SECRET are both set; if not, log "Telegram messaging not configured, skipping" and return early
- Create TelegramMessagingProvider(botToken, webhookSecret)
- Decorate fastify with `telegramMessaging` (type: TelegramMessagingProvider)
- Call provider.getMe() to verify bot token is valid; log bot username
- If TELEGRAM_WEBHOOK_URL is set, call provider.setWebhook(webhookUrl, webhookSecret); log "Telegram webhook registered"
- Plugin name: "telegram-messaging", dependencies: [] (no deps -- it only needs config which is already on fastify)
- Add Fastify module augmentation: `interface FastifyInstance { telegramMessaging?: TelegramMessagingProvider; }`

**src/server.ts** -- Import and register telegramMessagingPlugin after messagingPlugin:
```typescript
import telegramMessagingPlugin from "./plugins/telegram-messaging.js";
// ... in buildServer, after messagingPlugin registration:
await fastify.register(telegramMessagingPlugin);
```
  </action>
  <verify>
`npx tsc --noEmit` passes. Verify the provider file exports TelegramMessagingProvider. Verify server.ts registers the new plugin.
  </verify>
  <done>TelegramMessagingProvider implements MessagingProvider with send (text + photo + inline keyboard), validateWebhook (secret token header compare), parseInbound (message + callback_query), formatWebhookResponse (returns null), plus Telegram-specific answerCallbackQuery, sendChatAction, setWebhook, getMe. Plugin initializes provider, verifies bot, sets webhook. Server registers plugin.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- grammy is in package.json dependencies
- OutboundMessage has inlineKeyboard, photoUrl, parseMode fields
- TelegramMessagingProvider is exported from src/messaging/telegram-provider.ts
- Plugin is registered in server.ts
- Config includes TELEGRAM_WEBHOOK_URL and ADMIN_TELEGRAM_CHAT_ID
</verification>

<success_criteria>
- TelegramMessagingProvider implements full MessagingProvider interface using grammy Api class (NOT Bot)
- send() dispatches sendPhoto for photo messages with caption+keyboard, sendMessage for text+keyboard
- validateWebhook checks X-Telegram-Bot-Api-Secret-Token header
- parseInbound handles both message and callback_query Update types
- Plugin gracefully skips when Telegram env vars are not set
- TypeScript compilation succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/15-telegram-dm-integration/15-01-SUMMARY.md`
</output>
