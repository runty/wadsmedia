---
phase: 15-telegram-dm-integration
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - src/plugins/telegram-webhook.ts
  - src/server.ts
  - src/users/onboarding.ts
autonomous: true

must_haves:
  truths:
    - "Telegram DM triggers conversation engine and user receives a response"
    - "Callback query button taps are answered immediately and mapped to conversation input"
    - "Unknown Telegram users are created as pending with displayName from Telegram first_name"
    - "Blocked Telegram users receive rejection message"
    - "Forged webhooks (wrong/missing secret token) are rejected with 403"
    - "Only private chats are processed (group messages ignored)"
  artifacts:
    - path: "src/plugins/telegram-webhook.ts"
      provides: "POST /webhook/telegram route with message and callback_query handling"
      exports: ["default"]
    - path: "src/users/onboarding.ts"
      provides: "Telegram-aware onboarding that skips name-asking step"
      contains: "telegramChatId"
  key_links:
    - from: "src/plugins/telegram-webhook.ts"
      to: "src/conversation/engine.ts"
      via: "processConversation() call for active users"
      pattern: "processConversation"
    - from: "src/plugins/telegram-webhook.ts"
      to: "src/messaging/telegram-provider.ts"
      via: "fastify.telegramMessaging.answerCallbackQuery"
      pattern: "answerCallbackQuery"
    - from: "src/plugins/telegram-webhook.ts"
      to: "src/users/user.service.ts"
      via: "findUserByTelegramChatId and createUser"
      pattern: "findUserByTelegramChatId"
    - from: "src/plugins/telegram-webhook.ts"
      to: "src/users/onboarding.ts"
      via: "handleOnboarding for pending/blocked users"
      pattern: "handleOnboarding"
---

<objective>
Create the POST /webhook/telegram route that receives Telegram updates, resolves users by telegramChatId, handles both message and callback_query updates, and routes active users through the conversation engine with the Telegram provider.

Purpose: This is the core integration point -- where Telegram messages enter the system and get processed by the same conversation engine that handles SMS.

Output: Telegram webhook route plugin, updated onboarding for Telegram users.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-telegram-dm-integration/15-01-SUMMARY.md
@src/plugins/webhook.ts
@src/users/onboarding.ts
@src/users/user.service.ts
@src/conversation/engine.ts
@src/messaging/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create POST /webhook/telegram route with user resolution and conversation routing</name>
  <files>src/plugins/telegram-webhook.ts, src/server.ts</files>
  <action>
Create src/plugins/telegram-webhook.ts as a Fastify plugin (use fp from fastify-plugin):

Plugin name: "telegram-webhook", dependencies: ["database", "telegram-messaging"]

Guard: If `!fastify.telegramMessaging`, log "Telegram webhook not registered (provider not configured)" and return early. This makes the plugin safe to register even without Telegram env vars.

Register route: `POST /webhook/telegram` with `{ config: { rawBody: false } }` (Fastify parses JSON body automatically).

**Webhook validation preHandler:**
- Call `fastify.telegramMessaging.validateWebhook({ headers: request.headers, url: "", body: request.body })` -- url is unused for Telegram validation (it only checks the header)
- If invalid, reply 403 `{ error: "Invalid signature" }`

**Route handler logic:**

1. Immediately respond 200 OK with empty body: `reply.code(200).send({ ok: true })` -- Telegram expects fast acknowledgment. All processing happens after response.

2. Parse the update: `const message = fastify.telegramMessaging.parseInbound(request.body)`
   - If message.from is empty (neither message nor callback_query), return (already sent 200).

3. Determine if this is a callback_query by checking `(request.body as any).callback_query`:
   - If callback_query: immediately call `fastify.telegramMessaging.answerCallbackQuery(message.providerMessageId).catch(err => request.log.error({ err }, "Failed to answer callback query"))` -- MUST be called within 30 seconds or Telegram shows loading spinner. The providerMessageId for callback queries is the callback_query.id.
   - Also for callback_query: extract the original message chat type from `(request.body as any).callback_query.message?.chat?.type` to check private.

4. Filter: Only process private chats. Check chat type:
   - For message updates: `(request.body as any).message?.chat?.type`
   - For callback_query: `(request.body as any).callback_query.message?.chat?.type`
   - If not "private", log and return (group chat is Phase 16)

5. Resolve user by telegramChatId:
   ```typescript
   import { createUser, findUserByTelegramChatId } from "../users/user.service.js";

   const chatId = message.from;  // This is String(chat.id) from parseInbound
   let user = findUserByTelegramChatId(fastify.db, chatId);

   if (!user) {
     // Extract name from Telegram update for auto-onboarding
     const update = request.body as any;
     const tgUser = update.message?.from ?? update.callback_query?.from;
     const firstName = tgUser?.first_name ?? "Telegram User";
     const username = tgUser?.username ?? null;

     user = createUser(fastify.db, null, {
       telegramChatId: chatId,
       telegramUsername: username,
       displayName: firstName,  // Telegram provides name automatically
       status: "pending",
     });

     request.log.info({ chatId, name: firstName }, "New Telegram user created");
   }
   ```

6. Route based on user status:

   **Active users:**
   - Send typing indicator: `fastify.telegramMessaging.sendChatAction(chatId, "typing").catch(() => {})` (fire-and-forget)
   - Call processConversation with:
     - userId: user.id
     - replyAddress: chatId (the Telegram chat ID is the reply address)
     - displayName: user.displayName
     - isAdmin: user.isAdmin
     - messageBody: message.body (for callback_query this is the callback_data like "add:m:12345")
     - messaging: fastify.telegramMessaging (use the Telegram provider for replies!)
     - All other context from fastify (db, llm, toolRegistry, sonarr, radarr, tmdb, brave, plex, tautulli, config, log)
   - Wrap in try/catch. On error, send error message via telegramMessaging.send({ to: chatId, body: "Sorry, something went wrong." })

   **Pending users:**
   - Call handleOnboarding with messaging: fastify.telegramMessaging, pass user, messageBody, db, config, log
   - If onboardingReply is non-null, send via `fastify.telegramMessaging.send({ to: chatId, body: onboardingReply })`

   **Blocked users:**
   - Send "Sorry, your access has been revoked." via telegramMessaging

**src/server.ts** -- Import and register telegramWebhookPlugin after telegramMessagingPlugin and after webhookPlugin:
```typescript
import telegramWebhookPlugin from "./plugins/telegram-webhook.js";
// After webhook plugin registration:
await fastify.register(telegramWebhookPlugin);
```
  </action>
  <verify>
`npx tsc --noEmit` passes. The route is registered at POST /webhook/telegram. Plugin depends on database and telegram-messaging.
  </verify>
  <done>POST /webhook/telegram validates secret token, resolves users by telegramChatId, creates new pending users with Telegram first_name, sends typing indicator for active users, routes active users through processConversation with Telegram provider, handles pending/blocked via onboarding, answers callback queries immediately, only processes private chats.</done>
</task>

<task type="auto">
  <name>Task 2: Update onboarding for Telegram users (skip name-asking, admin notification via preferred channel)</name>
  <files>src/users/onboarding.ts</files>
  <action>
Update src/users/onboarding.ts to handle Telegram onboarding differently from SMS:

**Key difference:** Telegram provides first_name automatically at user creation time (done in webhook route). So Telegram pending users always have a non-null, non-empty displayName when they reach onboarding. They go straight to the "waiting for approval" state.

The existing SMS onboarding flow (null displayName -> ask name -> empty string -> capture name -> non-empty -> waiting) still works unchanged for SMS users because SMS users are created with null displayName.

**Modify the admin notification in the pending case (displayName is empty string -- SMS name capture):**

The current admin notification sends to config.ADMIN_PHONE only. Update it to also support ADMIN_TELEGRAM_CHAT_ID:

```typescript
// Notify admin about the new user via their preferred channel
const adminNotification = `New user request: ${trimmedName} (${replyAddress}). Approve via admin dashboard.`;

// Try Telegram admin notification if configured
if (config.ADMIN_TELEGRAM_CHAT_ID) {
  // We need a way to reach the Telegram provider here.
  // But onboarding receives a generic MessagingProvider.
  // For SMS onboarding, the messaging param is Twilio.
  // Admin notification should go to ADMIN_PHONE via the messaging param that was passed in (Twilio for SMS callers).
}
```

Actually, the cleaner approach: keep admin notification as-is in onboarding.ts (send to ADMIN_PHONE via whichever provider is passed). The Telegram webhook route creates users with displayName already set (non-empty), so they skip the name-capture step entirely and hit the "waiting for approval" branch which just returns a message -- no admin notification is sent from that branch.

So for Telegram users, admin notification about new users should happen in the **webhook route** (telegram-webhook.ts), not in onboarding.ts. Specifically, in Task 1's step 5 (user creation), right after createUser:

```typescript
// Notify admin about new Telegram user
const adminMsg = `New Telegram user: ${firstName}${username ? ` (@${username})` : ""} (chat: ${chatId}). Approve via admin dashboard.`;

// Send to admin via Telegram if configured, otherwise SMS
if (fastify.telegramMessaging && fastify.config.ADMIN_TELEGRAM_CHAT_ID) {
  fastify.telegramMessaging.send({ to: fastify.config.ADMIN_TELEGRAM_CHAT_ID, body: adminMsg }).catch(() => {});
} else if (fastify.messaging && fastify.config.ADMIN_PHONE) {
  fastify.messaging.send({ to: fastify.config.ADMIN_PHONE, body: adminMsg }).catch(() => {});
}
```

So the actual changes to onboarding.ts are minimal:
1. Update the comment at the top of handleOnboarding to document that Telegram users arrive with displayName already set (non-null, non-empty) and so skip the name-asking steps
2. No code changes needed -- the existing logic handles Telegram users correctly:
   - pending + null displayName: only SMS users (asks for name via TwiML response)
   - pending + empty displayName: only SMS users (captures name)
   - pending + non-empty displayName: both SMS and Telegram users (returns "waiting for approval" message)
   - blocked: both SMS and Telegram users (returns revoked message)

The key onboarding comment update:
```typescript
/**
 * Onboarding state machine for non-active users.
 *
 * SMS users: Created with null displayName, go through name-asking flow.
 * Telegram users: Created with displayName from Telegram first_name (non-null),
 * so they skip name-asking and immediately hit "waiting for approval" state.
 * Admin notification for new Telegram users is handled by the telegram-webhook plugin.
 *
 * Routes based on user status and displayName:
 * ...
 */
```

Move the admin notification for new Telegram users into telegram-webhook.ts (Task 1 already covers this -- add it to the user creation block in step 5).

Update the admin notification text in the SMS name-capture branch to clarify it's an SMS user: change "Add their number to PHONE_WHITELIST to approve" to "Approve via admin dashboard."
  </action>
  <verify>
`npx tsc --noEmit` passes. onboarding.ts comment documents Telegram user path. Admin notification text is updated.
  </verify>
  <done>Onboarding correctly handles Telegram users (displayName pre-set, skip name-asking). Admin notification for new Telegram users is sent from telegram-webhook plugin. Admin notification text for SMS users updated to reference dashboard.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- POST /webhook/telegram route exists in server plugin chain
- New Telegram users are created as pending with displayName from first_name
- Active Telegram users trigger processConversation with Telegram provider
- Callback queries are answered immediately with answerCallbackQuery
- Only private chats are processed
- Admin is notified of new Telegram users via preferred channel
</verification>

<success_criteria>
- Telegram DM from an active user triggers processConversation and response is sent back via Telegram
- Callback query button tap calls answerCallbackQuery immediately, then processes callback_data as message
- Unknown Telegram user is created as pending with Telegram-provided name, admin is notified
- Pending Telegram user sees "waiting for approval" message (no name-asking step)
- Blocked Telegram user sees rejection message
- Invalid/missing secret token returns 403
- Group chat messages are silently dropped
</success_criteria>

<output>
After completion, create `.planning/phases/15-telegram-dm-integration/15-02-SUMMARY.md`
</output>
