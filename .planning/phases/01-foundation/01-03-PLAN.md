---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - Dockerfile
  - docker-compose.yml
  - .dockerignore
  - src/plugins/health.ts
  - src/server.ts
autonomous: false

must_haves:
  truths:
    - "docker compose up --build starts the application successfully"
    - "Health check endpoint at GET /health returns 200 with JSON status including database check"
    - "Data persists across docker compose down and docker compose up cycles"
    - "Application logs are structured JSON visible via docker logs"
    - "Docker HEALTHCHECK reports container as healthy after startup"
  artifacts:
    - path: "Dockerfile"
      provides: "Multi-stage Docker build for production image"
      contains: "node:22-slim"
    - path: "docker-compose.yml"
      provides: "Docker Compose orchestration with volume mount"
      contains: "wadsmedia-data"
    - path: ".dockerignore"
      provides: "Docker build context exclusions"
      contains: "node_modules"
    - path: "src/plugins/health.ts"
      provides: "GET /health endpoint with database status check"
      exports: ["default"]
  key_links:
    - from: "src/server.ts"
      to: "src/plugins/health.ts"
      via: "fastify.register(healthPlugin)"
      pattern: "register.*health"
    - from: "src/plugins/health.ts"
      to: "fastify.db"
      via: "SQL SELECT 1 to verify database connectivity"
      pattern: "db.*sql|SELECT 1"
    - from: "Dockerfile"
      to: "drizzle/"
      via: "COPY drizzle migrations into production image"
      pattern: "COPY.*drizzle"
    - from: "docker-compose.yml"
      to: "Dockerfile"
      via: "build context"
      pattern: "build:"
---

<objective>
Create the health check endpoint, Docker multi-stage build, and docker-compose configuration. This completes Phase 1 by packaging the entire application into a production-ready container with volume persistence and health monitoring.

Purpose: The Docker container is the deployment target for all phases. The health check proves the application and database are operational. Volume persistence ensures data survives container restarts.
Output: A fully containerized application with health monitoring, ready for Phase 2+ feature development.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create health check plugin and Docker packaging</name>
  <files>
    src/plugins/health.ts
    src/server.ts
    Dockerfile
    docker-compose.yml
    .dockerignore
  </files>
  <action>
    1. Create src/plugins/health.ts:
       - Import `fp` from `'fastify-plugin'` and `sql` from `'drizzle-orm'`
       - Import `type FastifyInstance` from `'fastify'`
       - Export default plugin wrapped in `fp()`:
         - Register GET /health route
         - Inside the handler:
           - Try running `fastify.db.run(sql\`SELECT 1\`)` to check database
           - Set dbStatus to 'ok' on success, 'error' on catch
           - Compute overall status: 'ok' if all checks pass, 'degraded' otherwise
           - Return JSON with statusCode 200 (ok) or 503 (degraded):
             ```json
             {
               "status": "ok",
               "timestamp": "2026-02-13T...",
               "uptime": 123.456,
               "checks": { "database": "ok" }
             }
             ```
       - Set plugin name: `{ name: 'health' }`

    2. Update src/server.ts:
       - Add import: `import healthPlugin from './plugins/health.js'`
       - Register health plugin AFTER database plugin:
         ```typescript
         await fastify.register(databasePlugin);
         await fastify.register(healthPlugin);
         ```
       - Health plugin depends on database being registered first (it uses fastify.db)

    3. Create .dockerignore:
       ```
       node_modules
       dist
       .git
       .env
       *.db
       *.db-wal
       *.db-shm
       data/
       .planning/
       .claude/
       ```

    4. Create Dockerfile (multi-stage build):
       - **Builder stage** (FROM node:22-slim AS builder):
         - Install build tools: `apt-get update && apt-get install -y python3 make g++ && rm -rf /var/lib/apt/lists/*`
         - WORKDIR /app
         - Copy package*.json, run `npm ci`
         - Copy tsconfig.json and src/, run `npm run build`

       - **Production stage** (FROM node:22-slim):
         - WORKDIR /app
         - Copy from builder: dist/, node_modules/, package.json
         - Copy drizzle/ migrations folder directly (NOT from builder -- they are source files)
         - Set ENV NODE_ENV=production
         - VOLUME ["/data"]
         - EXPOSE 3000
         - HEALTHCHECK: `--interval=30s --timeout=5s --start-period=10s --retries=3 CMD node -e "fetch('http://localhost:3000/health').then(r => r.ok ? process.exit(0) : process.exit(1)).catch(() => process.exit(1))"`
         - CMD ["node", "dist/index.js"]

       IMPORTANT: The drizzle/ folder must be copied from the build context (not from builder stage) because it contains source SQL files, not compiled output. The COPY line should be:
       ```dockerfile
       COPY drizzle/ ./drizzle/
       ```

    5. Create docker-compose.yml:
       ```yaml
       services:
         wadsmedia:
           build: .
           ports:
             - "3000:3000"
           volumes:
             - wadsmedia-data:/data
           env_file:
             - .env
           environment:
             NODE_ENV: production
             DATABASE_PATH: /data/wadsmedia.db
           restart: unless-stopped

       volumes:
         wadsmedia-data:
       ```

    6. Create a minimal .env file for Docker testing:
       ```
       PORT=3000
       HOST=0.0.0.0
       NODE_ENV=production
       DATABASE_PATH=/data/wadsmedia.db
       ```

    7. Run `npm run build` and `npm run check` to verify the new health plugin compiles and lints.

    8. Build and start with Docker:
       ```
       docker compose up --build -d
       ```

    9. Verify:
       - `docker compose ps` shows container running
       - `curl http://localhost:3000/health` returns 200 with JSON body containing status, timestamp, uptime, checks.database
       - `docker compose logs` shows structured JSON log output (not pretty-printed)
       - Wait ~30s for HEALTHCHECK, then `docker inspect --format='{{.State.Health.Status}}' $(docker compose ps -q wadsmedia)` shows "healthy"

    10. Test data persistence:
        - `curl http://localhost:3000/health` works
        - `docker compose down`
        - `docker compose up -d`
        - `curl http://localhost:3000/health` still returns 200 (database persisted via volume)

    11. Clean up .env of any test values (leave it as the minimal required set or remove it and rely on .env.example as template).
  </action>
  <verify>
    - `npm run build` succeeds
    - `npm run check` passes
    - `docker compose up --build -d` builds and starts successfully
    - `curl http://localhost:3000/health` returns 200 with JSON: `{"status":"ok","checks":{"database":"ok"},...}`
    - `docker compose logs wadsmedia` shows JSON-formatted log lines
    - After `docker compose down && docker compose up -d`, health check still returns 200 (data persisted)
    - `docker inspect` shows health status as "healthy" (may need to wait 30-40s after startup)
  </verify>
  <done>
    Health endpoint responds at GET /health with 200 and database status. Docker multi-stage build produces a slim production image. docker-compose.yml mounts named volume for data persistence. Logs are structured JSON in docker logs. HEALTHCHECK passes.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify Docker deployment and health check</name>
  <files>None -- verification only</files>
  <action>
    Human verification of complete Phase 1 foundation: Fastify server in Docker with env config validation, SQLite database with auto-migrations, structured JSON logging, and health check endpoint. Data persists across container restarts via Docker volume.
  </action>
  <verify>
    1. Ensure Docker is running on your machine
    2. From the project root, run: `docker compose up --build -d`
    3. Wait about 10 seconds for startup, then run: `curl http://localhost:3000/health`
       - Expected: JSON response with `"status": "ok"` and `"checks": {"database": "ok"}`
    4. Check logs: `docker compose logs wadsmedia`
       - Expected: JSON-formatted log lines showing startup, database connection, and server listening
    5. Test persistence: `docker compose down && docker compose up -d`
       - After ~10s, run: `curl http://localhost:3000/health`
       - Expected: Still returns 200 OK (data volume persisted)
    6. Check Docker health: `docker inspect --format='{{.State.Health.Status}}' $(docker compose ps -q wadsmedia)`
       - Expected: "healthy" (wait ~40s after startup if needed)
    7. Clean up when done: `docker compose down` (add `-v` flag only if you want to remove the data volume)
  </verify>
  <done>User confirms: health check returns 200 with JSON, logs are structured JSON, data persists across restarts, Docker health status shows "healthy". Type "approved" or describe any issues.</done>
</task>

</tasks>

<verification>
1. `npm run build` -- all source compiles including health plugin
2. `npm run check` -- Biome passes
3. `docker compose up --build` -- container builds and starts
4. `curl localhost:3000/health` -- returns 200 with status JSON
5. `docker compose logs` -- shows structured JSON logging
6. Container restart preserves database (volume mount works)
7. Docker HEALTHCHECK reports "healthy"
</verification>

<success_criteria>
- Application runs in Docker container via docker-compose
- Health check at GET /health returns 200 with database status
- Data persists across container restarts via named volume
- Logs are structured JSON visible in docker logs
- Docker HEALTHCHECK reports healthy status
- All five Phase 1 success criteria from ROADMAP.md are satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
