---
phase: 08-status-and-notifications
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/notifications/types.ts
  - src/notifications/formatters.ts
  - src/notifications/notify.ts
  - src/plugins/notifications.ts
  - src/config.ts
  - src/server.ts
autonomous: true
user_setup:
  - service: sonarr
    why: "Webhook must be configured in Sonarr to POST events to WadsMedia"
    dashboard_config:
      - task: "Add webhook connection"
        location: "Sonarr -> Settings -> Connect -> + -> Webhook"
        details: "URL: http://<wadsmedia-host>:3000/webhook/sonarr?token=<NOTIFICATION_SECRET>, Method: POST, Events: On Grab + On Import"
  - service: radarr
    why: "Webhook must be configured in Radarr to POST events to WadsMedia"
    dashboard_config:
      - task: "Add webhook connection"
        location: "Radarr -> Settings -> Connect -> + -> Webhook"
        details: "URL: http://<wadsmedia-host>:3000/webhook/radarr?token=<NOTIFICATION_SECRET>, Method: POST, Events: On Grab + On Import"
  - service: wadsmedia
    why: "Shared secret for webhook authentication"
    env_vars:
      - name: NOTIFICATION_SECRET
        source: "Generate a random string (e.g., openssl rand -hex 32) and set in .env"

must_haves:
  truths:
    - "When Sonarr finishes downloading an episode, all active users receive an SMS notification"
    - "When Radarr finishes downloading a movie, all active users receive an SMS notification"
    - "Webhook endpoints reject requests with invalid or missing token"
    - "Notification messages are short template strings, not LLM-generated"
    - "App still starts and works normally if NOTIFICATION_SECRET is not set (notifications just won't be secured)"
  artifacts:
    - path: "src/notifications/types.ts"
      provides: "Sonarr and Radarr webhook payload type definitions"
      exports: ["SonarrWebhookPayload", "RadarrWebhookPayload"]
    - path: "src/notifications/formatters.ts"
      provides: "Template-based notification message formatters"
      exports: ["formatSonarrNotification", "formatRadarrNotification"]
    - path: "src/notifications/notify.ts"
      provides: "Notification dispatcher to all active users"
      exports: ["notifyAllActiveUsers"]
    - path: "src/plugins/notifications.ts"
      provides: "Fastify plugin with /webhook/sonarr and /webhook/radarr routes"
      contains: "webhook/sonarr"
    - path: "src/config.ts"
      provides: "NOTIFICATION_SECRET env var in config schema"
      contains: "NOTIFICATION_SECRET"
    - path: "src/server.ts"
      provides: "Notifications plugin registered in server"
      contains: "notificationsPlugin"
  key_links:
    - from: "src/plugins/notifications.ts"
      to: "src/notifications/formatters.ts"
      via: "formatSonarrNotification/formatRadarrNotification function calls"
      pattern: "format(Sonarr|Radarr)Notification"
    - from: "src/plugins/notifications.ts"
      to: "src/notifications/notify.ts"
      via: "notifyAllActiveUsers function call"
      pattern: "notifyAllActiveUsers"
    - from: "src/server.ts"
      to: "src/plugins/notifications.ts"
      via: "fastify.register(notificationsPlugin)"
      pattern: "register\\(notificationsPlugin\\)"
---

<objective>
Create a webhook-driven proactive notification service that receives Sonarr and Radarr event webhooks and sends SMS notifications to all active users when downloads complete or media is grabbed.

Purpose: Satisfies STAT-03 (proactive notifications without user asking). This is the only significant new infrastructure in Phase 8 -- webhook receiver routes, template-based message formatting, and a user notification dispatcher.
Output: Working notification webhook endpoints that, when configured in Sonarr/Radarr, send SMS to all active users on download events.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-status-and-notifications/08-RESEARCH.md

@src/plugins/webhook.ts
@src/plugins/messaging.ts
@src/messaging/types.ts
@src/users/user.service.ts
@src/db/schema.ts
@src/config.ts
@src/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create notification types, formatters, and dispatcher</name>
  <files>
    src/notifications/types.ts
    src/notifications/formatters.ts
    src/notifications/notify.ts
  </files>
  <action>
Create three modules in `src/notifications/`:

**1. `src/notifications/types.ts`** -- Webhook payload TypeScript interfaces:

```typescript
export interface SonarrWebhookPayload {
  eventType: string;
  instanceName?: string;
  series?: {
    id: number;
    title: string;
    path?: string;
    tvdbId?: number;
  };
  episodes?: Array<{
    id: number;
    episodeNumber: number;
    seasonNumber: number;
    title?: string;
  }>;
  release?: {
    quality?: string;
    releaseTitle?: string;
    size?: number;
  };
  isUpgrade?: boolean;
  downloadClient?: string;
}

export interface RadarrWebhookPayload {
  eventType: string;
  instanceName?: string;
  movie?: {
    id: number;
    title: string;
    year?: number;
    tmdbId?: number;
    imdbId?: string;
  };
  release?: {
    quality?: string;
    releaseTitle?: string;
    size?: number;
  };
  isUpgrade?: boolean;
  downloadClient?: string;
}
```

Use TypeScript interfaces (not Zod schemas) for webhook payloads since these are inbound from external systems with underdocumented schemas. The types use optional fields with `?.` access for safety. We do NOT validate these with Zod since the payload shape may vary between Sonarr/Radarr versions.

**2. `src/notifications/formatters.ts`** -- Template-based message formatters:

```typescript
import type { SonarrWebhookPayload, RadarrWebhookPayload } from "./types.js";

export function formatSonarrNotification(payload: SonarrWebhookPayload): string | null {
  switch (payload.eventType) {
    case "Download": {
      const series = payload.series?.title ?? "Unknown Show";
      const ep = payload.episodes?.[0];
      const epLabel = ep
        ? `S${String(ep.seasonNumber).padStart(2, "0")}E${String(ep.episodeNumber).padStart(2, "0")}`
        : "";
      const epTitle = ep?.title ? ` - ${ep.title}` : "";
      const prefix = payload.isUpgrade ? "Upgraded" : "Downloaded";
      return `${prefix}: ${series} ${epLabel}${epTitle}`;
    }
    case "Grab": {
      const series = payload.series?.title ?? "Unknown Show";
      const ep = payload.episodes?.[0];
      const epLabel = ep
        ? `S${String(ep.seasonNumber).padStart(2, "0")}E${String(ep.episodeNumber).padStart(2, "0")}`
        : "";
      return `Grabbing: ${series} ${epLabel}`;
    }
    default:
      return null;
  }
}

export function formatRadarrNotification(payload: RadarrWebhookPayload): string | null {
  switch (payload.eventType) {
    case "Download": {
      const title = payload.movie?.title ?? "Unknown Movie";
      const year = payload.movie?.year ? ` (${payload.movie.year})` : "";
      const prefix = payload.isUpgrade ? "Upgraded" : "Downloaded";
      return `${prefix}: ${title}${year}`;
    }
    case "Grab": {
      const title = payload.movie?.title ?? "Unknown Movie";
      return `Grabbing: ${title}`;
    }
    default:
      return null;
  }
}
```

Only handle `Download` (import complete) and `Grab` (sent to download client) events. Return `null` for all other event types (Rename, Health, Test, ApplicationUpdate, etc.) -- the plugin will skip notification for null messages.

**3. `src/notifications/notify.ts`** -- Dispatcher to all active users:

```typescript
import { eq } from "drizzle-orm";
import type { BetterSQLite3Database } from "drizzle-orm/better-sqlite3";
import type * as schema from "../db/schema.js";
import { users } from "../db/schema.js";
import type { MessagingProvider } from "../messaging/types.js";
import type { AppConfig } from "../config.js";
import type { FastifyBaseLogger } from "fastify";

type DB = BetterSQLite3Database<typeof schema>;

export async function notifyAllActiveUsers(
  db: DB,
  messaging: MessagingProvider,
  config: AppConfig,
  message: string,
  log: FastifyBaseLogger,
): Promise<void> {
  if (!config.TWILIO_PHONE_NUMBER) {
    log.warn("Cannot send notifications: TWILIO_PHONE_NUMBER not configured");
    return;
  }

  const activeUsers = db
    .select({ phone: users.phone })
    .from(users)
    .where(eq(users.status, "active"))
    .all();

  for (const user of activeUsers) {
    try {
      await messaging.send({
        to: user.phone,
        body: message,
        from: config.TWILIO_PHONE_NUMBER,
      });
    } catch (err) {
      log.error({ err, phone: user.phone }, "Failed to send notification");
    }
  }

  log.info({ userCount: activeUsers.length, message }, "Notification dispatched");
}
```

Follow the user.service.ts pattern: pure function with db as first parameter, using the same `DB` type alias. Check TWILIO_PHONE_NUMBER before sending; warn and return if not configured (graceful degradation per research pitfall 6).
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors.
Run `npx biome check src/notifications/` -- no lint errors.
Confirm all three files exist with expected exports.
  </verify>
  <done>
Notification types, formatters, and dispatcher modules exist. Formatters handle Download and Grab events for both Sonarr and Radarr with concise template strings. Dispatcher queries active users and sends via existing messaging infrastructure.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create notifications Fastify plugin with webhook routes</name>
  <files>
    src/plugins/notifications.ts
    src/config.ts
    src/server.ts
  </files>
  <action>
**1. Add NOTIFICATION_SECRET to config** (`src/config.ts`):

Add to the Zod env schema (alongside other optional vars):
```typescript
// Notifications (optional, for webhook security)
NOTIFICATION_SECRET: z.string().min(1).optional(),
```

Place it after the Sonarr/Radarr env vars block and before the Users block.

**2. Create notifications plugin** (`src/plugins/notifications.ts`):

Create a Fastify plugin following the existing plugin pattern (see `src/plugins/webhook.ts`):

```typescript
import type { FastifyInstance, FastifyReply, FastifyRequest } from "fastify";
import fp from "fastify-plugin";
import { formatSonarrNotification, formatRadarrNotification } from "../notifications/formatters.js";
import { notifyAllActiveUsers } from "../notifications/notify.js";
import type { SonarrWebhookPayload, RadarrWebhookPayload } from "../notifications/types.js";

export default fp(
  async (fastify: FastifyInstance) => {
    // Skip registration if messaging is not configured (same graceful-skip pattern as sonarr/radarr plugins)
    if (!fastify.config.TWILIO_PHONE_NUMBER) {
      fastify.log.warn(
        "Notifications disabled: TWILIO_PHONE_NUMBER not configured",
      );
      return;
    }

    const notificationSecret = fastify.config.NOTIFICATION_SECRET;

    // Token validation preHandler
    const validateToken = async (request: FastifyRequest, reply: FastifyReply) => {
      if (notificationSecret) {
        const token = (request.query as Record<string, string>).token;
        if (token !== notificationSecret) {
          request.log.warn("Invalid notification webhook token");
          reply.code(403).send({ error: "Invalid token" });
          return;
        }
      }
    };

    // POST /webhook/sonarr -- receives Sonarr event notifications
    fastify.post(
      "/webhook/sonarr",
      { preHandler: [validateToken] },
      async (request, reply) => {
        const payload = request.body as SonarrWebhookPayload;
        const message = formatSonarrNotification(payload);

        if (message) {
          // Fire-and-forget: don't block the webhook response
          notifyAllActiveUsers(
            fastify.db,
            fastify.messaging,
            fastify.config,
            message,
            request.log,
          ).catch((err) => request.log.error({ err }, "Sonarr notification dispatch failed"));
        }

        reply.code(200).send({ ok: true });
      },
    );

    // POST /webhook/radarr -- receives Radarr event notifications
    fastify.post(
      "/webhook/radarr",
      { preHandler: [validateToken] },
      async (request, reply) => {
        const payload = request.body as RadarrWebhookPayload;
        const message = formatRadarrNotification(payload);

        if (message) {
          notifyAllActiveUsers(
            fastify.db,
            fastify.messaging,
            fastify.config,
            message,
            request.log,
          ).catch((err) => request.log.error({ err }, "Radarr notification dispatch failed"));
        }

        reply.code(200).send({ ok: true });
      },
    );

    fastify.log.info(
      { secured: !!notificationSecret },
      "Notification webhook routes registered",
    );
  },
  { name: "notifications", dependencies: ["database", "messaging"] },
);
```

Key design decisions:
- **Graceful skip** when TWILIO_PHONE_NUMBER is not set (same pattern as sonarr/radarr plugins -- research pitfall 6)
- **Token validation** via query parameter `?token=<secret>` as a preHandler hook (research recommendation for webhook security)
- **Fire-and-forget** notification dispatch: webhook responds 200 immediately, notifications sent asynchronously (same pattern as conversation processing in webhook.ts)
- **Dependencies:** `database` and `messaging` (NOT `webhook` -- distinct route paths `/webhook/sonarr` and `/webhook/radarr` don't conflict with existing `/webhook/twilio`)
- **JSON body parsing:** Sonarr/Radarr send `application/json` POST bodies. Fastify's built-in JSON parser handles this automatically (unlike Twilio which uses form-encoded, requiring @fastify/formbody).

**3. Register in server** (`src/server.ts`):

Add import at top:
```typescript
import notificationsPlugin from "./plugins/notifications.js";
```

Register after `webhookPlugin` (last in plugin chain):
```typescript
await fastify.register(notificationsPlugin);
```
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors.
Run `npx biome check src/` -- no lint errors.
Confirm `src/plugins/notifications.ts` exists and defines routes for `/webhook/sonarr` and `/webhook/radarr`.
Confirm `src/config.ts` includes `NOTIFICATION_SECRET` in the schema.
Confirm `src/server.ts` imports and registers `notificationsPlugin`.
  </verify>
  <done>
Notification webhook routes `/webhook/sonarr` and `/webhook/radarr` are registered and active. Token-based security is applied when NOTIFICATION_SECRET is configured. Plugin gracefully skips when messaging is unavailable. Server wiring complete. Sonarr/Radarr can POST events and all active users receive SMS notifications for Download and Grab events.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npx biome check src/` passes with zero errors
3. `src/notifications/types.ts` exports SonarrWebhookPayload and RadarrWebhookPayload interfaces
4. `src/notifications/formatters.ts` exports formatSonarrNotification and formatRadarrNotification
5. `src/notifications/notify.ts` exports notifyAllActiveUsers
6. `src/plugins/notifications.ts` registers /webhook/sonarr and /webhook/radarr routes
7. `src/config.ts` includes NOTIFICATION_SECRET optional env var
8. `src/server.ts` imports and registers notificationsPlugin
9. Formatters return null for non-user-relevant events (Rename, Health, Test, etc.)
10. Plugin skips gracefully when TWILIO_PHONE_NUMBER is not configured
</verification>

<success_criteria>
STAT-03 fully satisfied: webhook endpoints receive Sonarr/Radarr events and proactively notify all active users via SMS.
Notification messages are template-based (not LLM-generated) for speed and predictability.
Webhook security via shared secret token prevents unauthorized notifications.
No new npm dependencies required.
</success_criteria>

<output>
After completion, create `.planning/phases/08-status-and-notifications/08-02-SUMMARY.md`
</output>
